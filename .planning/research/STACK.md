# Stack Research

**Domain:** RSVP Speed Reading PWA (client-side only, TypeScript + React + Rust/WASM)
**Researched:** 2026-02-23
**Confidence:** MEDIUM (WebSearch and WebFetch denied; findings from training data through August 2025 + Context7 where available. Versions flagged LOW should be verified before pinning.)

---

## Recommended Stack

### Core Technologies

| Technology | Version | Purpose | Why Recommended |
|------------|---------|---------|-----------------|
| Vite | ^6.x | Build tool + dev server + PWA bundler | Fastest HMR, first-class WASM support via `vite-plugin-wasm`, PWA plugin ecosystem mature. Replaced CRA as the standard React scaffold. |
| React | ^19.x | UI framework | Fixed choice per project constraints. React 19 RC stabilized; concurrent features useful for throttling RSVP render loop without jank. |
| TypeScript | ^5.4+ | Type safety across frontend + WASM bindings | wasm-bindgen generates TypeScript types natively; TS 5.4 has improved inference for discriminated unions (useful for reader state machine). |
| wasm-pack | ^0.13.x | Compile Rust crates to WASM + generate JS/TS bindings | The standard Rust→WASM toolchain. Outputs ES module + TypeScript types. Used by every major Rust/WASM tutorial and crate. |
| wasm-bindgen | ^0.2.92+ | Rust↔JS FFI glue | Automatically generated by wasm-pack; enables calling Rust functions from TypeScript with zero-copy where possible. |
| vite-plugin-wasm | ^3.x | Load `.wasm` files in Vite without configuration pain | Handles WASM MIME type, top-level await, and chunking correctly. Without it, WASM loading in Vite requires manual fetch + instantiate. |

### Document Processing (Rust Crates compiled to WASM)

This is the most critical and highest-risk part of the stack. Rust crate support for WASM compilation varies widely.

| Crate | Version | Purpose | Confidence | Notes |
|-------|---------|---------|------------|-------|
| `pdf-extract` | ~0.7.x | PDF text extraction | LOW | Pure Rust, extracts text from PDF. Does NOT require system libs (unlike poppler). WASM compilation feasibility needs verification — it has no_std issues in some versions. Alternative: use pdfium-render with a pre-compiled WASM binary. |
| `lopdf` | ~0.32.x | Lower-level PDF read/write | LOW | Pure Rust PDF library; used by pdf-extract internally. More control but requires you to traverse the PDF object tree yourself. |
| `epub` | ~2.1.x | EPUB parsing | MEDIUM | Pure Rust, parses EPUB 2 and 3. Reads chapter structure and HTML content. Well-maintained. Should compile to WASM (no system deps). |
| `docx-rs` | ~0.4.x | DOCX parsing | LOW | Pure Rust DOCX reader. Less mature than the Python/JS alternatives. Verify WASM compatibility before committing. |
| `zip` | ~0.6.x | ZIP/container format (EPUB/DOCX are ZIPs) | MEDIUM | EPUB and DOCX are ZIP containers. epub crate handles this internally; docx-rs does too. May be needed for custom extraction. |
| `scraper` | ~0.20.x | HTML parsing (EPUB content is HTML) | MEDIUM | Pure Rust HTML parser (wraps html5ever). Needed to extract text from EPUB chapters which are XHTML files. Compiles to WASM. |

**IMPORTANT: PDF parsing is the highest-risk item.** Pure Rust PDF parsing that compiles cleanly to WASM is not solved by a single dominant crate. Two viable strategies:

1. **pdf-extract crate**: Attempt compilation; may need feature flags to exclude non-WASM-safe deps.
2. **pdfium-render**: Wraps Google's PDFium library. Has a pre-compiled WASM build. Higher fidelity but ~40MB binary. See https://github.com/ajrcarey/pdfium-render.

Recommendation: Start with `pdf-extract` and fall back to pdfium-render if WASM compilation fails or text extraction quality is poor.

### PWA Stack

| Technology | Version | Purpose | Why Recommended |
|------------|---------|---------|-----------------|
| vite-plugin-pwa | ^0.21.x | Service worker generation, manifest injection, offline support | The standard Vite PWA plugin. Uses Workbox under the hood. Auto-generates `manifest.webmanifest` and service worker. |
| Workbox | (bundled with vite-plugin-pwa) | Service worker strategies (cache-first, network-first) | Industry standard for PWA caching strategies. |
| Web Share Target API | (browser API, no library) | Receive shared content from other apps (web pages, files) | Declared in `manifest.webmanifest` as `share_target`. No npm package — configured in manifest JSON and handled via fetch event in service worker. |

### Frontend Supporting Libraries

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Zustand | ^5.x | State management for reader state (play/pause, WPM, word index) | Simpler than Redux, no boilerplate. RSVP reader has a small but real state machine (idle → loading → playing → paused → done). Zustand handles this cleanly. |
| `use-debounce` | ^10.x | Debounce WPM slider changes | Prevents thrashing word interval timer on rapid slider moves. |
| Tailwind CSS | ^4.x | Utility-first styling | Fast to build responsive UI. Tailwind v4 uses CSS-native variables, no PostCSS config required. Good fit for a focused single-screen app. |
| `@radix-ui/react-slider` | ^1.x | Accessible WPM speed slider | Radix primitives are headless, accessible, and Tailwind-compatible. Better than rolling a custom accessible slider. |
| `@radix-ui/react-progress` | ^1.x | Reading progress indicator | Same rationale as slider. |

### Development Tools

| Tool | Purpose | Notes |
|------|---------|-------|
| Rust toolchain (rustup) | Compile Rust to WASM | `rustup target add wasm32-unknown-unknown` required. Use stable channel. |
| wasm-pack | Build Rust crate to WASM pkg | Run `wasm-pack build --target web` for Vite compatibility (not `--target bundler`). |
| Vitest | Unit testing for TypeScript | Comes with Vite ecosystem. WASM testing requires `vitest --browser` or jsdom with WASM support. |
| Playwright | E2E testing for PWA flows | Can test share target handler via direct URL navigation. |
| ESLint + `@typescript-eslint` | Linting | Standard. |
| Prettier | Formatting | Standard. |

---

## Installation

```bash
# Scaffold React + TypeScript + Vite project
npm create vite@latest rsvp-reader -- --template react-ts

# Core frontend deps
npm install zustand use-debounce

# UI components
npm install @radix-ui/react-slider @radix-ui/react-progress

# Styling
npm install -D tailwindcss @tailwindcss/vite

# PWA
npm install -D vite-plugin-pwa

# WASM support in Vite
npm install -D vite-plugin-wasm vite-plugin-top-level-await

# Dev tools
npm install -D vitest @vitest/coverage-v8 playwright
```

```bash
# Rust WASM toolchain
rustup target add wasm32-unknown-unknown
cargo install wasm-pack

# Create Rust crate for document processing
cargo new --lib rsvp-wasm
# In Cargo.toml, set crate-type = ["cdylib"]
```

```toml
# rsvp-wasm/Cargo.toml key dependencies
[dependencies]
wasm-bindgen = "0.2"
pdf-extract = "0.7"        # verify WASM compat
epub = "2.1"
docx-rs = "0.4"
scraper = "0.20"
serde = { version = "1", features = ["derive"] }
serde-wasm-bindgen = "0.6"

[lib]
crate-type = ["cdylib"]
```

---

## Alternatives Considered

| Category | Recommended | Alternative | Why Not |
|----------|-------------|-------------|---------|
| Build tool | Vite 6 | Webpack 5 | Webpack requires manual WASM config, slower DX, no first-class PWA plugin. |
| Build tool | Vite 6 | Parcel | Less ecosystem maturity for WASM; fewer examples. |
| State management | Zustand | Redux Toolkit | RTK is overkill for a 5-state reader machine with no server sync. |
| State management | Zustand | React Context + useReducer | Fine but verbose; Zustand gives same simplicity with better DevTools. |
| Styling | Tailwind CSS | CSS Modules | Both work; Tailwind is faster to iterate on responsive layouts. |
| Styling | Tailwind CSS | styled-components | Runtime CSS-in-JS adds unnecessary overhead for a PWA; bundle size matters. |
| PDF parsing | pdf-extract | PDF.js (Mozilla) | PDF.js is a JS library, not WASM/Rust. Works but defeats the Rust architecture decision. If Rust PDF parsing proves too hard, PDF.js is the pragmatic fallback. |
| PDF parsing | pdf-extract | pdfium-render | Better fidelity but ~40MB WASM binary. Use if pdf-extract text extraction quality is poor. |
| EPUB parsing | epub crate | epub-parser (JS) | Rust crate preferred per project constraints; epub crate is pure Rust and mature. |
| PWA plugin | vite-plugin-pwa | Manual Workbox | Manual workbox setup is 200+ lines of config; vite-plugin-pwa handles it in ~20 lines. |
| UI components | Radix UI | shadcn/ui | shadcn/ui wraps Radix anyway; use raw Radix when you don't need shadcn's opinionated defaults. |
| UI components | Radix UI | Material UI (MUI) | MUI adds heavy dependencies and opinionated theming. RSVP reader is minimal UI — no need for a full design system. |

---

## What NOT to Use

| Avoid | Why | Use Instead |
|-------|-----|-------------|
| Create React App (CRA) | Unmaintained since 2023; no WASM support; slow build | Vite |
| Next.js / Remix | Server-side rendering frameworks for a fully client-side app adds complexity with no benefit | Vite + React SPA |
| PDF.js for the Rust WASM path | It's a JS library; mixing it in breaks the Rust document processing architecture | pdf-extract or pdfium-render |
| `wasm-bindgen` target `bundler` | Vite requires `--target web` (not `bundler`) for correct ES module output | `wasm-pack build --target web` |
| Top-level await without `vite-plugin-top-level-await` | WASM instantiation uses top-level await; without the plugin, browsers that don't support it natively will break | Add `vite-plugin-top-level-await` |
| Inline WASM (import as base64) | Increases initial JS bundle size dramatically; WASM should be fetched separately and cached by service worker | Keep WASM as separate `.wasm` asset |
| Service worker with `skipWaiting` + `clients.claim` carelessly | Causes race conditions where old page JS calls new WASM API that has changed | Use `vite-plugin-pwa`'s default prompt-to-update UX |
| `react-spring` or `framer-motion` for the RSVP word flash | Animation libraries add frame budgets you don't control; RSVP display needs sub-millisecond timing via `setInterval` / `requestAnimationFrame` with direct DOM manipulation or a single `useState` update | Plain `setInterval` + `useState` |

---

## Web Share Target API — Configuration Details

The Web Share Target is declared in `manifest.webmanifest`, not in JS. This is a common source of confusion.

```json
// public/manifest.webmanifest
{
  "name": "RSVP Reader",
  "short_name": "RSVP",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0f0f0f",
  "theme_color": "#0f0f0f",
  "icons": [...],
  "share_target": {
    "action": "/share-target",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url",
      "files": [
        {
          "name": "file",
          "accept": ["application/pdf", "application/epub+zip", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
        }
      ]
    }
  }
}
```

The service worker intercepts the `POST /share-target` request:

```typescript
// In service worker (generated by vite-plugin-pwa with custom handler)
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  if (url.pathname === '/share-target' && event.request.method === 'POST') {
    event.respondWith(handleShareTarget(event.request));
  }
});
```

**Platform support (as of early 2026):**
- Android Chrome/Edge: Full support (URLs + files)
- Desktop Chrome/Edge: Full support
- iOS Safari: URL sharing supported; file sharing via share target is partial (iOS 17+ improved but not complete)
- Firefox: Not supported

This is MEDIUM confidence — iOS file share target support is a moving target.

---

## RSVP Display Timing — Critical Pattern

The RSVP word display loop must use `setInterval` (or `setTimeout` recursion) in a `useRef` to avoid React re-render overhead:

```typescript
// Anti-pattern: setState in setInterval causes double renders
// Correct pattern:
const intervalRef = useRef<ReturnType<typeof setInterval>>(null);
const wordIndexRef = useRef(0);

const startPlaying = useCallback(() => {
  intervalRef.current = setInterval(() => {
    wordIndexRef.current += 1;
    setCurrentWordIndex(wordIndexRef.current); // ONE setState per tick
  }, 60000 / wpm); // ms per word
}, [wpm]);
```

At 300 WPM = 200ms per word. At 600 WPM = 100ms per word. React 19 concurrent mode handles this fine but the interval ref pattern avoids stale closure issues.

---

## Stack Patterns by Variant

**If PDF text extraction quality is poor with pdf-extract:**
- Switch to pdfium-render (Rust wrapper around Google PDFium)
- Accept the ~30-40MB WASM binary increase
- Cache aggressively via service worker

**If Rust WASM compilation for PDF/DOCX is blocked:**
- Fall back to PDF.js (Mozilla, mature JS library) for PDFs
- Fall back to mammoth.js for DOCX
- Keep Rust only for EPUB (cleanest WASM path)
- Accept that this diverges from the pure-Rust architecture

**If iOS Safari file share target support is critical:**
- Provide a fallback: file input button `<input type="file" accept=".pdf,.epub,.docx">` visible on all platforms
- Share target is an enhancement, not a requirement

**If bundle size is a concern (WASM can be large):**
- Lazy-load the WASM module on first document import, not on app startup
- Use Vite's dynamic import: `const wasm = await import('./rsvp-wasm/pkg')`
- Service worker pre-caches after first load

---

## Version Compatibility

| Package | Compatible With | Notes |
|---------|-----------------|-------|
| vite ^6.x | vite-plugin-pwa ^0.21.x | vite-plugin-pwa 0.20+ required for Vite 6 support |
| vite ^6.x | vite-plugin-wasm ^3.x | Confirm ^3.x supports Vite 6; was updated in 2024 |
| wasm-pack ^0.13 | wasm-bindgen ^0.2.92 | wasm-pack pins wasm-bindgen version; let wasm-pack manage it |
| React ^19 | Zustand ^5.x | Zustand 5 has React 19 compatibility fixes for StrictMode |
| Tailwind ^4.x | @tailwindcss/vite | Tailwind 4 ships its own Vite plugin; do NOT use `tailwindcss` PostCSS plugin with Vite 4+ |

**Confidence note on versions:** All version numbers are from training data (August 2025). Verify current versions via `npm info [package] version` and `cargo search [crate]` before pinning. Rust crate versions in particular should be verified — pdf-extract and docx-rs are less frequently updated than JS packages.

---

## Sources

- Training data (through August 2025) — Vite, React, Zustand, Tailwind, Radix UI, wasm-pack: HIGH confidence (stable, widely documented ecosystems)
- Training data — Rust crates (pdf-extract, docx-rs, epub): MEDIUM confidence for epub, LOW confidence for pdf-extract and docx-rs (WASM compilation feasibility unverified)
- Training data — Web Share Target API, PWA manifest spec: MEDIUM confidence (spec is stable, platform support evolves)
- Training data — RSVP timing patterns: MEDIUM confidence (setInterval + useRef is established React pattern)
- Official Rust/WASM docs: https://rustwasm.github.io/docs/wasm-bindgen/ (verify wasm-bindgen version)
- Official wasm-pack docs: https://rustwasm.github.io/docs/wasm-pack/
- Web Share Target spec: https://w3c.github.io/web-share-target/
- vite-plugin-pwa docs: https://vite-pwa-org.netlify.app/
- pdfium-render GitHub: https://github.com/ajrcarey/pdfium-render (fallback PDF strategy)
- WebSearch and WebFetch unavailable during this research session — versions should be verified before implementation

---

*Stack research for: RSVP Speed Reading PWA*
*Researched: 2026-02-23*
