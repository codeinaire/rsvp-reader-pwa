---
phase: 04-pwa-web-share-target
plan: 03
type: execute
wave: 2
depends_on:
  - 04-02
files_modified:
  - src/App.tsx
  - src/components/EntryScreen/EntryScreen.tsx
autonomous: true
requirements:
  - IMPT-01
  - PWA-02
  - PWA-03

must_haves:
  truths:
    - "When the app opens at /share-target/?url=... or /share-target/?text=..., it navigates to /load-url with the URL in location state"
    - "On app startup, if IndexedDB has a persisted document, it is loaded into the store (enables offline reading)"
    - "After every successful PDF or URL import, the document is persisted to IndexedDB"
    - "EntryScreen has a URL input field that lets the user manually enter a URL and trigger extraction"
    - "The /load-url route is registered in the app router and renders UrlLoader"
    - "iOS users: file picker and paste paths on EntryScreen work as before (no regression)"
  artifacts:
    - path: "src/App.tsx"
      provides: "URL share param detection + /load-url route + idb-keyval hydration on startup"
      contains: "load-url"
    - path: "src/components/EntryScreen/EntryScreen.tsx"
      provides: "URL input field for manual URL entry (iOS fallback path)"
      contains: "url"
  key_links:
    - from: "src/App.tsx ShareTargetHandler"
      to: "/load-url route"
      via: "navigate('/load-url', { state: { url }, replace: true })"
      pattern: "navigate.*load-url"
    - from: "src/App.tsx"
      to: "hydrateLastDocument"
      via: "useEffect on mount calling hydrateLastDocument()"
      pattern: "hydrateLastDocument"
    - from: "src/components/EntryScreen/EntryScreen.tsx"
      to: "/load-url route"
      via: "navigate('/load-url', { state: { url } })"
      pattern: "navigate.*load-url"
    - from: "setDocument (store)"
      to: "persistDocument"
      via: "called after every successful import in EntryScreen and App.tsx"
      pattern: "persistDocument"
---

<objective>
Wire UrlLoader into the router, extend ShareTargetHandler in App.tsx to detect GET URL shares and navigate to /load-url, add document hydration on app startup from IndexedDB, extend EntryScreen with a URL input field, and call persistDocument after every successful import.

Purpose: This plan connects all the pieces built in Plans 01 and 02 into a working user flow. Without this wiring, the URL extraction code and UrlLoader component are unreachable.

Output: Users can share a URL from Android Chrome → app opens → fetches article → preview screen. Users can manually enter a URL in EntryScreen (iOS path). Last imported document is available offline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-web-share-target/04-RESEARCH.md
@.planning/phases/04-pwa-web-share-target/04-02-SUMMARY.md
@src/App.tsx
@src/components/EntryScreen/EntryScreen.tsx
@src/store/rsvp-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend App.tsx — URL share detection, /load-url route, and IndexedDB hydration on startup</name>
  <files>
    src/App.tsx
  </files>
  <action>
Three changes to `src/App.tsx`:

**1. Add /load-url route** — import UrlLoader and register the route inside `&lt;Routes&gt;`:

```typescript
import UrlLoader from './components/UrlLoader/UrlLoader'
// ...
&lt;Route path="/load-url" element={&lt;UrlLoader /&gt;} /&gt;
```

**2. Extend ShareTargetHandler to handle GET URL shares.**

On Android Chrome, when a user shares a URL from another app, the Web Share Target spec delivers it as a POST to `/share-target/` with the URL in the `text` or `url` form field. The scoped SW (`share-target-sw.js`) intercepts the POST and stores it in Cache, then postMessages the client. HOWEVER — for GET-style URL shares (desktop Chrome, when the manifest declares GET), the params arrive as query strings on the page URL.

Add a second `useEffect` inside `ShareTargetHandler` that runs once on mount and checks if the current URL has `?url=` or `?text=` query params that look like valid URLs. This handles desktop Chrome GET URL sharing:

```typescript
useEffect(() => {
  // Handle GET share target — URL/text shared from desktop Chrome
  // On Android, URL often arrives in the 'text' field (Android's share intent maps URLs there)
  const params = new URLSearchParams(window.location.search)
  const rawUrl = params.get('url') || ''
  const rawText = params.get('text') || ''
  const candidate = rawUrl || rawText

  if (candidate && isValidHttpUrl(candidate)) {
    navigate('/load-url', { state: { url: candidate }, replace: true })
    // Clean query params from the URL bar
    window.history.replaceState({}, '', '/')
  }
}, [navigate]) // runs once on mount
```

Add the `isValidHttpUrl` helper function (not inside the component — define it at module level):

```typescript
function isValidHttpUrl(str: string): boolean {
  try {
    const u = new URL(str)
    return u.protocol === 'http:' || u.protocol === 'https:'
  } catch {
    return false
  }
}
```

**3. Add IndexedDB hydration on app startup.**

Create a new `DocumentHydrator` side-effect component (like `ShareTargetHandler`) that runs once on mount, checks IndexedDB for a persisted document, and loads it into the store if found. This enables offline reading of the last document.

```typescript
import { hydrateLastDocument } from './lib/document-persistence'

function DocumentHydrator() {
  const setDocument = useRsvpStore((s) => s.setDocument)
  const wordList = useRsvpStore((s) => s.wordList)

  useEffect(() => {
    // Only hydrate if no document is already loaded (don't overwrite a freshly imported doc)
    if (wordList.length > 0) return

    hydrateLastDocument().then((saved) => {
      if (saved) {
        setDocument(saved.words, saved.title)
      }
    })
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  return null
}
```

Mount `DocumentHydrator` inside `BrowserRouter`, alongside `ShareTargetHandler`:

```typescript
export default function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;ShareTargetHandler /&gt;
      &lt;DocumentHydrator /&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;EntryScreen /&gt;} /&gt;
        &lt;Route path="/preview" element={&lt;TextPreview /&gt;} /&gt;
        &lt;Route path="/load-url" element={&lt;UrlLoader /&gt;} /&gt;
        &lt;Route path="/read" element={&lt;RSVPReader /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  )
}
```

Do NOT change the existing ShareTargetHandler SHARED_PDF logic — it handles PDF share target and must remain intact.

Verify: `npm run build` exits 0. Check that `/load-url` route is in the compiled output.
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | grep -E "error TS|ERROR" | head -10 && grep -l "load-url" dist/assets/*.js 2>/dev/null | head -3 && echo "WIRING OK"</automated>
    <manual>Check src/App.tsx: /load-url route present, isValidHttpUrl helper defined, DocumentHydrator component defined and mounted, ShareTargetHandler has GET URL detection useEffect.</manual>
  </verify>
  <done>Build exits 0. /load-url route registered. DocumentHydrator mounted. ShareTargetHandler has URL share detection. isValidHttpUrl defined at module scope.</done>
</task>

<task type="auto">
  <name>Task 2: Extend EntryScreen with URL input field and call persistDocument after every import</name>
  <files>
    src/components/EntryScreen/EntryScreen.tsx
  </files>
  <action>
Two changes to EntryScreen:

**1. Add URL input field for manual URL entry.**

This serves as the iOS fallback path for URL import (IMPT-01 + PWA-03): iOS does not support Web Share Target for URLs, so iOS users type or paste a URL directly into EntryScreen.

Add a URL input section to EntryScreen. Place it between the file picker section and the paste text section (collapsible `&lt;details&gt;` pattern already used for paste). Design decision (Claude's discretion): a simple `&lt;details&gt;` accordion labeled "Or enter a URL" with an `&lt;input type="url"&gt;` and a "Fetch article" button.

Add the following imports:
```typescript
import { useNavigate } from 'react-router-dom' // already imported
// Add to existing state:
const [urlInput, setUrlInput] = useState('')
const [isUrlOpen, setIsUrlOpen] = useState(false)
```

Add the URL input section in the JSX (after the file picker card, before or after the paste section):

```tsx
{/* URL input — primary fallback for iOS (no Share Target), also desktop convenience */}
&lt;details
  className="w-full"
  open={isUrlOpen}
  onToggle={(e) => setIsUrlOpen((e.target as HTMLDetailsElement).open)}
&gt;
  &lt;summary className="cursor-pointer text-sm text-gray-400 hover:text-gray-200 select-none py-2"&gt;
    Or enter a URL
  &lt;/summary&gt;
  &lt;div className="mt-2 flex gap-2"&gt;
    &lt;input
      type="url"
      value={urlInput}
      onChange={(e) => setUrlInput(e.target.value)}
      placeholder="https://example.com/article"
      className="flex-1 bg-gray-800 border border-gray-700 rounded-lg px-3 py-2 text-sm text-white placeholder-gray-500 focus:outline-none focus:border-red-500"
      onKeyDown={(e) => {
        if (e.key === 'Enter') handleUrlFetch()
      }}
    />
    &lt;button
      onClick={handleUrlFetch}
      disabled={!urlInput.trim()}
      className="px-4 py-2 bg-red-600 hover:bg-red-500 disabled:opacity-40 disabled:cursor-not-allowed text-white text-sm rounded-lg transition-colors"
    &gt;
      Fetch
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/details&gt;
```

Add the `handleUrlFetch` function inside the component:

```typescript
function handleUrlFetch() {
  const trimmed = urlInput.trim()
  if (!trimmed) return
  // Validate: must be http or https URL
  try {
    const u = new URL(trimmed)
    if (u.protocol !== 'http:' && u.protocol !== 'https:') {
      showError('Please enter a valid http:// or https:// URL.')
      return
    }
  } catch {
    showError('Please enter a valid URL (e.g. https://example.com/article).')
    return
  }
  navigate('/load-url', { state: { url: trimmed } })
}
```

**2. Call `persistDocument` after every successful import.**

Import the persistence function:
```typescript
import { persistDocument } from '../../lib/document-persistence'
```

In `handleFile` (PDF/TXT import), after the `setDocument(result.words, title)` call, add:
```typescript
persistDocument(result.words, title)
```

In `handlePasteSubmit` (paste text import), after `setDocument(words, null)`, add:
```typescript
persistDocument(words, null)
```

Note: `persistDocument` is async but fire-and-forget here — do NOT await it. The user navigation happens immediately; persistence is a background write. The existing function already handles errors silently.

Do NOT change any other EntryScreen logic — drag-and-drop, file picker, loading state, patience timer, error auto-dismiss all remain unchanged.

Verify: `npm run build` exits 0. No TypeScript errors.
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | grep -E "error TS|ERROR" | head -10 && echo "ENTRYSCREEN OK"</automated>
    <manual>Check EntryScreen.tsx: URL input field exists, handleUrlFetch navigates to /load-url, persistDocument called after setDocument in both handleFile and handlePasteSubmit.</manual>
  </verify>
  <done>Build exits 0. EntryScreen has URL input with Fetch button. handleUrlFetch validates URL and navigates to /load-url. persistDocument called (fire-and-forget) after both file import and paste import. No regression in existing import flows.</done>
</task>

</tasks>

<verification>
- `npm run build` exits 0 with no TypeScript errors
- `src/App.tsx`: /load-url route present, ShareTargetHandler has GET URL detection, DocumentHydrator mounted
- `src/components/EntryScreen/EntryScreen.tsx`: URL input section renders, persistDocument imported and called after import
- Existing PDF drag-drop and paste flows still compile (no regression)
</verification>

<success_criteria>
- Build exits 0 — all four routes wired (/, /preview, /load-url, /read)
- URL share detection in ShareTargetHandler handles ?url= and ?text= params on Android and desktop Chrome
- DocumentHydrator restores last document from IndexedDB on app startup (offline reading enabled)
- EntryScreen has URL input that navigates to /load-url — iOS users can manually enter URLs
- persistDocument called after every successful import (PDF, paste, URL extraction) — last document always persisted
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-web-share-target/04-03-SUMMARY.md`
</output>
