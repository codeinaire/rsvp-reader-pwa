---
phase: 04-pwa-web-share-target
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/url-extractor.ts
  - src/lib/document-persistence.ts
  - src/components/UrlLoader/UrlLoader.tsx
autonomous: true
requirements:
  - IMPT-01
  - PWA-02
  - PWA-03

must_haves:
  truths:
    - "extractArticle(url) returns {title, words} for a CORS-accessible URL"
    - "extractArticle(url) returns {type:'cors', message:...} for a CORS-blocked URL"
    - "extractArticle(url) returns {type:'parse', message:...} when Readability finds no article"
    - "UrlLoader displays the hostname of the URL being fetched while extraction is in progress"
    - "UrlLoader navigates to /preview on successful extraction"
    - "UrlLoader shows actionable error message and back button on CORS/parse/network failure"
    - "persistDocument(words, title) writes to IndexedDB without throwing"
    - "hydrateLastDocument() reads from IndexedDB and returns {words, title} or null on miss/error"
  artifacts:
    - path: "src/lib/url-extractor.ts"
      provides: "Client-side URL article extraction using @mozilla/readability"
      exports: ["extractArticle", "ExtractResult", "ExtractError"]
    - path: "src/lib/document-persistence.ts"
      provides: "IndexedDB persistence for last imported document via idb-keyval"
      exports: ["persistDocument", "hydrateLastDocument"]
    - path: "src/components/UrlLoader/UrlLoader.tsx"
      provides: "Loading screen for URL extraction with hostname display and error state"
      min_lines: 50
  key_links:
    - from: "src/components/UrlLoader/UrlLoader.tsx"
      to: "src/lib/url-extractor.ts"
      via: "extractArticle() call in useEffect"
      pattern: "extractArticle"
    - from: "src/components/UrlLoader/UrlLoader.tsx"
      to: "useRsvpStore setDocument"
      via: "setDocument(result.words, result.title)"
      pattern: "setDocument"
    - from: "src/components/UrlLoader/UrlLoader.tsx"
      to: "/preview route"
      via: "navigate('/preview', { replace: true })"
      pattern: "navigate.*preview"
---

<objective>
Build the URL extraction library (using @mozilla/readability), the document persistence layer (using idb-keyval for IndexedDB), and the UrlLoader screen component that shows fetch progress with the hostname visible.

Purpose: These are the pure new capabilities for Phase 4 that require no routing or wiring changes. Separating them into their own plan keeps concerns focused and allows parallel execution with Plan 01 (PWA foundation).

Output: Three new files — url-extractor.ts, document-persistence.ts, UrlLoader.tsx — that Plan 03 will wire into the app shell and EntryScreen.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-pwa-web-share-target/04-RESEARCH.md
@src/store/rsvp-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @mozilla/readability + idb-keyval, create url-extractor.ts and document-persistence.ts</name>
  <files>
    package.json
    src/lib/url-extractor.ts
    src/lib/document-persistence.ts
  </files>
  <action>
Install dependencies:
```
npm install @mozilla/readability idb-keyval
```

Create `src/lib/url-extractor.ts`:

```typescript
import { Readability } from '@mozilla/readability'

export interface ExtractResult {
  title: string
  words: string[]
}

export interface ExtractError {
  type: 'cors' | 'parse' | 'empty' | 'network'
  message: string
}

/**
 * Fetch a URL and extract article text using @mozilla/readability.
 * Returns ExtractResult on success, ExtractError on any failure.
 *
 * CORS note: Most major sites will block cross-origin fetch.
 * This is expected and by design — the error path offers paste as fallback.
 */
export async function extractArticle(
  url: string
): Promise<ExtractResult | ExtractError> {
  let html: string
  try {
    const response = await fetch(url)
    if (!response.ok) {
      return {
        type: 'network',
        message: `The page returned an error (${response.status}). Try pasting the text instead.`,
      }
    }
    html = await response.text()
  } catch (err) {
    // TypeError from fetch = CORS block or network failure
    const isCors =
      err instanceof TypeError &&
      (err.message.toLowerCase().includes('fetch') ||
        err.message.toLowerCase().includes('cors') ||
        err.message.toLowerCase().includes('network'))
    return {
      type: isCors ? 'cors' : 'network',
      message: isCors
        ? 'This site does not allow apps to fetch its content directly. Paste the article text instead.'
        : 'Could not reach the page. Check your connection and try again.',
    }
  }

  // Parse with native DOMParser — no jsdom needed in the browser
  const parser = new DOMParser()
  const doc = parser.parseFromString(html, 'text/html')

  // Set base URL so Readability resolves relative links correctly
  const base = doc.createElement('base')
  base.href = url
  doc.head.prepend(base)

  const reader = new Readability(doc)
  const article = reader.parse()

  if (!article || !article.textContent?.trim()) {
    return {
      type: 'parse',
      message:
        'Could not find readable article text on this page. Try pasting the text instead.',
    }
  }

  // Tokenize to words (same pattern as tokenize.ts — whitespace split, filter empty)
  const words = article.textContent
    .trim()
    .split(/\s+/)
    .filter((w) => w.length > 0)

  if (words.length < 10) {
    return {
      type: 'empty',
      message: 'Not enough readable text found on this page. Try pasting the text instead.',
    }
  }

  return {
    title: article.title?.trim() || new URL(url).hostname,
    words,
  }
}
```

Create `src/lib/document-persistence.ts`:

```typescript
import { get, set } from 'idb-keyval'

const PERSIST_KEY = 'rsvp-last-document'

interface PersistedDocument {
  words: string[]
  title: string | null
}

/**
 * Persist the last imported document to IndexedDB.
 * Called after every successful document import (PDF or URL).
 * Silent on failure — storage quota or private browsing will not crash the app.
 *
 * Why IndexedDB (not localStorage): word arrays for long PDFs can exceed
 * localStorage's 5–10 MB cap. idb-keyval adds ~295 bytes brotli'd.
 */
export async function persistDocument(
  words: string[],
  title: string | null
): Promise<void> {
  try {
    await set(PERSIST_KEY, { words, title } satisfies PersistedDocument)
  } catch {
    // Storage quota exceeded, private browsing, or IndexedDB unavailable — silent fail
  }
}

/**
 * Load the last persisted document from IndexedDB.
 * Returns the document if found and valid (>= 10 words), otherwise null.
 * Called once on app init to hydrate offline reading capability.
 */
export async function hydrateLastDocument(): Promise<PersistedDocument | null> {
  try {
    const saved = await get<PersistedDocument>(PERSIST_KEY)
    if (saved && Array.isArray(saved.words) && saved.words.length >= 10) {
      return saved
    }
    return null
  } catch {
    // IndexedDB unavailable — return null (app works without persistence)
    return null
  }
}
```

TypeScript note: `@mozilla/readability` has its own type declarations. If the TypeScript compiler complains about missing types, add `@types/mozilla__readability` but this package should include its own types.

Verify: `npm run build` exits 0 with no TypeScript errors from the new files.
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | grep -E "error|ERROR|✓ built" | head -20 && echo "BUILD CHECK DONE"</automated>
    <manual>Check that src/lib/url-extractor.ts and src/lib/document-persistence.ts compile cleanly. No TypeScript errors for extractArticle, ExtractResult, ExtractError, persistDocument, hydrateLastDocument.</manual>
  </verify>
  <done>Both files compile without errors. extractArticle is exported with correct type signatures. persistDocument and hydrateLastDocument are exported and compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create UrlLoader component with hostname display, loading state, and error fallback</name>
  <files>
    src/components/UrlLoader/UrlLoader.tsx
  </files>
  <action>
Create `src/components/UrlLoader/UrlLoader.tsx`.

This component is displayed when the app receives a URL to extract — either via the Web Share Target (App.tsx navigates here with `{ state: { url } }`) or in Plan 03 when the user manually enters a URL in EntryScreen.

The component must:
1. Show the hostname of the URL being fetched ("Fetching article from example.com…") — NOT just a spinner. The user decision requires the URL hostname to be visible.
2. Call `extractArticle(url)` in a useEffect on mount
3. On success: call `setDocument(result.words, result.title)` then `navigate('/preview', { replace: true })`
4. On error: show the error message with a "Go back" button that navigates to `'/'` with `replace: true`
5. If no URL in location state (e.g., user navigates directly to /load-url): redirect to `/`

Use Tailwind classes matching the app's dark theme (bg-gray-950 background, text-white, red accent for hostname). Keep design minimal — this is a transient loading screen.

```typescript
import { useEffect, useState } from 'react'
import { useNavigate, useLocation } from 'react-router-dom'
import { extractArticle } from '../../lib/url-extractor'
import { useRsvpStore } from '../../store/rsvp-store'

interface LocationState {
  url?: string
}

export default function UrlLoader() {
  const navigate = useNavigate()
  const location = useLocation()
  const setDocument = useRsvpStore((s) => s.setDocument)
  const [error, setError] = useState<string | null>(null)

  const url = (location.state as LocationState)?.url ?? ''

  const hostname = (() => {
    try {
      return new URL(url).hostname
    } catch {
      return url
    }
  })()

  useEffect(() => {
    if (!url) {
      // No URL provided — redirect to entry (user navigated here directly)
      navigate('/', { replace: true })
      return
    }

    let cancelled = false

    extractArticle(url).then((result) => {
      if (cancelled) return

      if ('type' in result) {
        // Error result
        setError(result.message)
      } else {
        // Success — load document and go to preview
        setDocument(result.words, result.title)
        navigate('/preview', { replace: true })
      }
    })

    return () => {
      cancelled = true
    }
  }, [url, navigate, setDocument])

  if (error) {
    return (
      <div className="fixed inset-0 bg-gray-950 flex flex-col items-center justify-center gap-6 p-8 text-center">
        <p className="text-red-400 text-lg max-w-sm">{error}</p>
        <button
          onClick={() => navigate('/', { replace: true })}
          className="px-6 py-3 bg-gray-800 hover:bg-gray-700 text-white rounded-lg transition-colors"
        >
          Go back and paste instead
        </button>
      </div>
    )
  }

  return (
    <div className="fixed inset-0 bg-gray-950 flex flex-col items-center justify-center gap-4 p-8 text-center">
      <p className="text-gray-400 text-base">Fetching article from</p>
      <p className="text-white text-xl font-medium break-all max-w-sm">{hostname}</p>
      {/* Simple pulsing indicator — no library needed */}
      <div className="mt-4 flex gap-1.5">
        <span className="w-2 h-2 bg-red-500 rounded-full animate-bounce [animation-delay:0ms]" />
        <span className="w-2 h-2 bg-red-500 rounded-full animate-bounce [animation-delay:150ms]" />
        <span className="w-2 h-2 bg-red-500 rounded-full animate-bounce [animation-delay:300ms]" />
      </div>
    </div>
  )
}
```

Verify: `npm run build` exits 0. The UrlLoader component compiles without TypeScript errors. The /load-url route will be wired in Plan 03.
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | grep -E "error TS|ERROR" | head -10 && ls src/components/UrlLoader/UrlLoader.tsx && echo "URLLOADER OK"</automated>
    <manual>Check UrlLoader.tsx exists. No TypeScript errors. extractArticle import resolves. useRsvpStore import resolves.</manual>
  </verify>
  <done>src/components/UrlLoader/UrlLoader.tsx exists. Build exits 0. Component imports extractArticle and useRsvpStore without errors.</done>
</task>

</tasks>

<verification>
- `npm run build` exits 0 with no TypeScript errors
- `src/lib/url-extractor.ts` exports `extractArticle`, `ExtractResult`, `ExtractError`
- `src/lib/document-persistence.ts` exports `persistDocument`, `hydrateLastDocument`
- `src/components/UrlLoader/UrlLoader.tsx` renders loading state (hostname visible) and error state (back button)
</verification>

<success_criteria>
- All three files compile cleanly in the build
- extractArticle handles fetch errors (returns ExtractError) and success (returns ExtractResult with words array)
- UrlLoader shows hostname during load, shows actionable error message on failure, navigates to /preview on success
- persistDocument and hydrateLastDocument use idb-keyval with silent error handling
</success_criteria>

<output>
After completion, create `.planning/phases/04-pwa-web-share-target/04-02-SUMMARY.md`
</output>
