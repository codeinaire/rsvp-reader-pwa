---
phase: 03-import-ui-reading-view
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/components/RSVPReader/TextPanel.tsx
  - src/components/RSVPReader/FontSizePanel.tsx
  - src/components/RSVPReader/PlaybackControls.tsx
autonomous: true
requirements: [VIEW-01, VIEW-02, VIEW-04]

must_haves:
  truths:
    - "TextPanel renders all words as spans with one ref per word (callback ref pattern — no per-word useRef)"
    - "TextPanel dims to ~50% opacity while RSVP is playing, returning to full when paused — driven by isPlaying from Zustand"
    - "Auto-scroll triggers scrollIntoView({ block: 'nearest', behavior: 'smooth' }) on currentWordIndex change, skipped when user has manually scrolled within 2 seconds"
    - "Font size +/- buttons in FontSizePanel clamp to allowed ranges (rsvp: 48-120px step 8, text: 12-32px step 4)"
    - "Gear icon in PlaybackControls toggles FontSizePanel visibility with local state"
  artifacts:
    - path: "src/components/RSVPReader/TextPanel.tsx"
      provides: "Scrollable word list panel with highlight, auto-scroll, and opacity dimming"
      min_lines: 60
      exports: ["TextPanel"]
    - path: "src/components/RSVPReader/FontSizePanel.tsx"
      provides: "+/- font size controls for rsvpFontSize and textFontSize"
      min_lines: 40
      exports: ["FontSizePanel"]
    - path: "src/components/RSVPReader/PlaybackControls.tsx"
      provides: "Gear icon toggle that shows/hides FontSizePanel inline"
      contains: "FontSizePanel"
  key_links:
    - from: "src/components/RSVPReader/TextPanel.tsx"
      to: "useRsvpStore"
      via: "currentWordIndex, isPlaying, wordList, textFontSize selectors"
      pattern: "useRsvpStore.*currentWordIndex"
    - from: "src/components/RSVPReader/TextPanel.tsx"
      to: "wordRefs.current[currentWordIndex]"
      via: "useEffect → scrollIntoView"
      pattern: "scrollIntoView"
    - from: "src/components/RSVPReader/FontSizePanel.tsx"
      to: "useRsvpStore"
      via: "setRsvpFontSize, setTextFontSize actions"
      pattern: "setRsvpFontSize|setTextFontSize"
    - from: "src/components/RSVPReader/PlaybackControls.tsx"
      to: "FontSizePanel"
      via: "showFontPanel local state + conditional render"
      pattern: "showFontPanel"
---

<objective>
Create TextPanel (scrollable full-text with word highlighting, auto-scroll, and dimming) and FontSizePanel (+/- font size controls), then extend PlaybackControls with a gear icon that toggles FontSizePanel. These components are assembled into the dual-view layout in Plan 04.

Purpose: Each component is self-contained and testable before the RSVPReader layout rewrite in Plan 04. TextPanel contains the most complex logic (ref array, scroll detection, DOM mutation) and benefits from isolated implementation.
Output: TextPanel.tsx, FontSizePanel.tsx, and updated PlaybackControls.tsx — all functional with store-connected state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-import-ui-reading-view/03-CONTEXT.md
@.planning/phases/03-import-ui-reading-view/03-RESEARCH.md
@src/store/rsvp-store.ts
@src/components/RSVPReader/PlaybackControls.tsx
@.planning/phases/03-import-ui-reading-view/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TextPanel.tsx — word list with highlight, auto-scroll, and opacity dimming</name>
  <files>src/components/RSVPReader/TextPanel.tsx</files>
  <action>
Create `src/components/RSVPReader/TextPanel.tsx`. This component renders all words in the document as individual `<span>` elements with direct DOM manipulation for highlighting — NOT React state — to avoid re-rendering thousands of spans on every word advance.

**Full implementation:**

```tsx
import { useEffect, useRef } from 'react'
import { useRsvpStore } from '../../store/rsvp-store'

/**
 * TextPanel — scrollable full-text panel for the dual-view reading layout.
 *
 * Architecture decisions (per RESEARCH.md):
 * - Word highlight via direct DOM mutation (not React state) — avoids O(n) re-render
 *   at 300+ WPM on documents with 10,000+ words.
 * - Auto-scroll uses scrollIntoView({ block: 'nearest' }) — only scrolls if the word
 *   would go off-screen, preventing jarring continuous centering.
 * - Manual scroll detection: boolean ref + 2s timeout. User scroll pauses auto-scroll;
 *   resumes automatically after 2 seconds of no scroll activity.
 * - Ref array uses callback ref pattern — one mutable array, populated on render,
 *   avoids creating thousands of individual useRef objects.
 */
export function TextPanel() {
  const wordList = useRsvpStore((s) => s.wordList)
  const currentWordIndex = useRsvpStore((s) => s.currentWordIndex)
  const isPlaying = useRsvpStore((s) => s.isPlaying)
  const textFontSize = useRsvpStore((s) => s.textFontSize)

  // Mutable ref array: one entry per word span
  // Populated by callback refs during render, reset when wordList changes
  const wordRefs = useRef<(HTMLSpanElement | null)[]>([])

  // Track the previously highlighted span for efficient DOM removal
  const prevIndexRef = useRef<number>(-1)

  // Manual scroll detection: true = user took control; auto-scroll paused
  const userScrolledRef = useRef(false)
  const scrollResumeTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)

  // Ref for the scrollable panel container
  const panelRef = useRef<HTMLDivElement>(null)

  // Reset ref array when word list changes (new document loaded)
  useEffect(() => {
    wordRefs.current = new Array(wordList.length).fill(null)
    prevIndexRef.current = -1
    userScrolledRef.current = false
  }, [wordList.length])

  // Manual scroll listener — sets userScrolledRef, clears after 2 seconds
  useEffect(() => {
    const panel = panelRef.current
    if (!panel) return

    function onScroll() {
      userScrolledRef.current = true
      if (scrollResumeTimerRef.current) clearTimeout(scrollResumeTimerRef.current)
      scrollResumeTimerRef.current = setTimeout(() => {
        userScrolledRef.current = false
      }, 2000)
    }

    panel.addEventListener('scroll', onScroll, { passive: true })
    return () => {
      panel.removeEventListener('scroll', onScroll)
      if (scrollResumeTimerRef.current) clearTimeout(scrollResumeTimerRef.current)
    }
  }, [])

  // Word highlight + auto-scroll: runs on every currentWordIndex change
  useEffect(() => {
    // Remove highlight from previous word (direct DOM mutation)
    const prevEl = wordRefs.current[prevIndexRef.current]
    if (prevEl) {
      prevEl.style.backgroundColor = ''
      prevEl.style.color = ''
      prevEl.style.borderRadius = ''
      prevEl.style.padding = ''
    }

    // Apply highlight to current word
    const currEl = wordRefs.current[currentWordIndex]
    if (currEl) {
      currEl.style.backgroundColor = '#fde047' // yellow-300
      currEl.style.color = '#111827'            // gray-900
      currEl.style.borderRadius = '3px'
      currEl.style.padding = '0 2px'
    }

    prevIndexRef.current = currentWordIndex

    // Auto-scroll: skip if user recently scrolled manually
    if (!userScrolledRef.current && currEl) {
      currEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' })
    }
  }, [currentWordIndex])

  return (
    <div
      ref={panelRef}
      className={[
        'flex-1 overflow-y-auto px-5 py-5',
        'transition-opacity duration-300',
        isPlaying ? 'opacity-50' : 'opacity-100',
      ].join(' ')}
    >
      <p
        className="leading-relaxed text-gray-200 font-sans"
        style={{ fontSize: textFontSize }}
      >
        {wordList.map((word, i) => (
          <span
            key={i}
            ref={(el) => { wordRefs.current[i] = el }}
          >
            {word}{' '}
          </span>
        ))}
      </p>
    </div>
  )
}
```

**Critical implementation notes:**
- `key={i}` is intentional and correct here — wordList never mutates during a session, so index-as-key causes no issues
- The `prevIndexRef` starts at -1 so the first `prevEl` lookup on index 0 is safely null (no-op)
- `transition-opacity duration-300` provides the CSS transition for dimming — the opacity switches between `opacity-50` and `opacity-100` via class toggling, not inline style, to get CSS hardware acceleration
- `flex-1` allows TextPanel to fill remaining height in the flex column container (set by RSVPReader in Plan 04)
- `overflow-y-auto` enables independent scrolling without the page scrolling
- Font size applied via `style={{ fontSize: textFontSize }}` — textFontSize is a number (px) from Zustand store
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | tail -5</automated>
    <manual>Component builds without errors. Exports named export `TextPanel`.</manual>
  </verify>
  <done>TextPanel.tsx exports TextPanel. Uses callback ref pattern for word refs. Applies direct DOM highlight mutation on currentWordIndex change. Implements manual scroll detection with 2s resume timer. Dims to opacity-50 while isPlaying, full opacity when paused. Build exits 0.</done>
</task>

<task type="auto">
  <name>Task 2: Create FontSizePanel.tsx and extend PlaybackControls with gear icon toggle</name>
  <files>src/components/RSVPReader/FontSizePanel.tsx, src/components/RSVPReader/PlaybackControls.tsx</files>
  <action>
**Part A: Create FontSizePanel.tsx**

```tsx
import { useRsvpStore } from '../../store/rsvp-store'

/**
 * FontSizePanel — independent +/- controls for RSVP word display and full text panel font sizes.
 * Reads and writes to Zustand store (rsvpFontSize, textFontSize) — persisted to localStorage.
 *
 * Step sizes: RSVP word = 8px steps (48–120px), full text = 4px steps (12–32px).
 * Clamping is enforced in the store actions (setRsvpFontSize, setTextFontSize).
 */
export function FontSizePanel() {
  const rsvpFontSize = useRsvpStore((s) => s.rsvpFontSize)
  const textFontSize = useRsvpStore((s) => s.textFontSize)
  const setRsvpFontSize = useRsvpStore((s) => s.setRsvpFontSize)
  const setTextFontSize = useRsvpStore((s) => s.setTextFontSize)

  return (
    <div className="flex flex-col gap-3 p-3 bg-gray-800 rounded-xl border border-gray-700 min-w-[180px]">
      {/* RSVP word font size */}
      <div className="flex items-center justify-between gap-3">
        <span className="text-xs text-gray-400 whitespace-nowrap">RSVP word</span>
        <div className="flex items-center gap-1.5">
          <button
            onClick={() => setRsvpFontSize(rsvpFontSize - 8)}
            aria-label="Decrease RSVP word font size"
            className="w-7 h-7 flex items-center justify-center text-gray-300 hover:text-white border border-gray-700 hover:border-gray-500 rounded-md transition-colors text-base leading-none"
          >
            −
          </button>
          <span className="text-sm text-gray-300 tabular-nums w-10 text-center">
            {rsvpFontSize}px
          </span>
          <button
            onClick={() => setRsvpFontSize(rsvpFontSize + 8)}
            aria-label="Increase RSVP word font size"
            className="w-7 h-7 flex items-center justify-center text-gray-300 hover:text-white border border-gray-700 hover:border-gray-500 rounded-md transition-colors text-base leading-none"
          >
            +
          </button>
        </div>
      </div>

      {/* Full text font size */}
      <div className="flex items-center justify-between gap-3">
        <span className="text-xs text-gray-400 whitespace-nowrap">Full text</span>
        <div className="flex items-center gap-1.5">
          <button
            onClick={() => setTextFontSize(textFontSize - 4)}
            aria-label="Decrease full text font size"
            className="w-7 h-7 flex items-center justify-center text-gray-300 hover:text-white border border-gray-700 hover:border-gray-500 rounded-md transition-colors text-base leading-none"
          >
            −
          </button>
          <span className="text-sm text-gray-300 tabular-nums w-10 text-center">
            {textFontSize}px
          </span>
          <button
            onClick={() => setTextFontSize(textFontSize + 4)}
            aria-label="Increase full text font size"
            className="w-7 h-7 flex items-center justify-center text-gray-300 hover:text-white border border-gray-700 hover:border-gray-500 rounded-md transition-colors text-base leading-none"
          >
            +
          </button>
        </div>
      </div>
    </div>
  )
}
```

**Part B: Update PlaybackControls.tsx**

Add a gear icon button and local `showFontPanel` state to the existing PlaybackControls component. FontSizePanel renders as an absolutely positioned overlay or inline below the controls row — use `relative` on the container and `absolute bottom-full right-0 mb-2` on the panel to float it above the controls without affecting layout.

Changes to PlaybackControls.tsx:
1. Add `import { useState } from 'react'`
2. Add `import { FontSizePanel } from './FontSizePanel'`
3. Add `const [showFontPanel, setShowFontPanel] = useState(false)` inside the component
4. Add a gear icon button at the end of the controls row (after the WPM display span):

```tsx
{/* Font size settings toggle */}
<div className="relative">
  <button
    onClick={() => setShowFontPanel(!showFontPanel)}
    aria-label="Font size settings"
    aria-expanded={showFontPanel}
    className={`p-1.5 rounded-md border transition-colors ${
      showFontPanel
        ? 'text-white border-gray-500 bg-gray-700'
        : 'text-gray-400 border-gray-700 hover:text-white hover:border-gray-500'
    }`}
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className="w-4 h-4"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
      strokeWidth={2}
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
      />
      <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
  </button>

  {showFontPanel && (
    <div className="absolute bottom-full right-0 mb-2 z-20">
      <FontSizePanel />
    </div>
  )}
</div>
```

**The existing controls structure** must remain unchanged. Add the gear icon `<div className="relative">` as the last sibling inside the outer controls flex container, after the WPM display `<span>`.
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | tail -5</automated>
    <manual>Build exits 0. FontSizePanel.tsx and updated PlaybackControls.tsx are clean TypeScript.</manual>
  </verify>
  <done>FontSizePanel.tsx exports FontSizePanel with +/- buttons for rsvpFontSize (step 8) and textFontSize (step 4). PlaybackControls.tsx imports FontSizePanel, renders gear icon button with local showFontPanel toggle, FontSizePanel appears as absolute overlay when toggled. Build exits 0.</done>
</task>

</tasks>

<verification>
Run: `cd /workspace && nvm use 22 2>/dev/null; npm run build`
Expected: Exit 0, no TypeScript errors.

Run: `cd /workspace && nvm use 22 2>/dev/null; npm test 2>&1 | tail -10`
Expected: All tests pass — no regressions in orp.test.ts or scheduler.test.ts.
</verification>

<success_criteria>
1. TextPanel.tsx: callback ref pattern (not per-word useRef), direct DOM mutation for highlight (not React state), scrollIntoView on currentWordIndex change, 2s manual scroll resume timer, opacity dimming via Tailwind class, textFontSize from store.
2. FontSizePanel.tsx: +/- buttons for two independent font sizes, ranges enforced at store level.
3. PlaybackControls.tsx: gear icon toggles FontSizePanel visibility via local useState, FontSizePanel positioned as absolute overlay above controls.
4. Build exits 0. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-import-ui-reading-view/03-03-SUMMARY.md`
</output>
