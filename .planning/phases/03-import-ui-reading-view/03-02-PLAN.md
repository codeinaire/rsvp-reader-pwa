---
phase: 03-import-ui-reading-view
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - public/manifest.json
  - public/share-target-sw.js
  - src/App.tsx
autonomous: true
requirements: [IMPT-02]

must_haves:
  truths:
    - "public/manifest.json contains a valid share_target entry accepting application/pdf files via POST multipart/form-data at /share-target/"
    - "public/share-target-sw.js contains a fetch event handler that intercepts POST /share-target/, stores the file via Cache API, and postMessages all window clients"
    - "App.tsx registers share-target-sw.js as a scoped service worker (scoped to /share-target/) on mount and listens for SHARED_PDF messages to trigger document import"
    - "The share target architecture is complete; full activation requires Phase 4 PWA service worker installation"
  artifacts:
    - path: "public/manifest.json"
      provides: "PWA manifest with name, short_name, start_url, display, icons placeholder, and share_target"
      contains: "share_target"
    - path: "public/share-target-sw.js"
      provides: "Service worker fetch handler for POST /share-target/ — stores PDF in Cache API, postMessages clients, redirects to /"
      contains: "share-target-v1"
    - path: "src/App.tsx"
      provides: "Service worker registration for share-target-sw.js (scoped) + navigator.serviceWorker message listener"
      contains: "share-target-sw.js"
  key_links:
    - from: "public/manifest.json"
      to: "/share-target/"
      via: "share_target.action"
      pattern: "share-target"
    - from: "public/share-target-sw.js"
      to: "Cache API 'share-target-v1'"
      via: "caches.open('share-target-v1').put('/shared-pdf', ...)"
      pattern: "share-target-v1"
    - from: "src/App.tsx"
      to: "documentService.parseFile + navigate('/preview')"
      via: "navigator.serviceWorker 'message' event listener"
      pattern: "SHARED_PDF"
---

<objective>
Implement the Web Share Target architecture for IMPT-02: a PWA manifest entry that tells Android Chrome to offer RSVP Reader in the system share sheet when sharing PDF files, a scoped service worker that handles the incoming POST, and an app-side message listener that processes the received file.

Purpose: Android users can share PDFs directly into RSVP Reader from any app. The manifest + SW handler are architecturally complete; the share target becomes user-visible after Phase 4 installs and registers the full app service worker (PWA installation gate).
Output: public/manifest.json, public/share-target-sw.js, updated App.tsx with SW registration and message listener.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/03-import-ui-reading-view/03-CONTEXT.md
@.planning/phases/03-import-ui-reading-view/03-RESEARCH.md
@src/App.tsx
@src/services/document-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public/manifest.json with PWA identity and share_target entry</name>
  <files>public/manifest.json</files>
  <action>
Create `public/manifest.json` with a complete minimal PWA manifest including the share_target entry. Vite serves files in `public/` at the root path — no import needed; the HTML link tag (or Vite's auto-injection) will serve it.

**manifest.json content:**
```json
{
  "name": "RSVP Reader",
  "short_name": "RSVP",
  "description": "Read faster with one word at a time — zero friction PDF import",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#030712",
  "theme_color": "#030712",
  "icons": [
    {
      "src": "/vite.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "any maskable"
    }
  ],
  "share_target": {
    "action": "/share-target/",
    "method": "POST",
    "enctype": "multipart/form-data",
    "params": {
      "files": [
        {
          "name": "pdf",
          "accept": ["application/pdf", ".pdf"]
        }
      ]
    }
  }
}
```

**Notes:**
- `background_color` and `theme_color` use gray-950 hex (`#030712`) matching the app's dark background
- `icons` uses the existing `vite.svg` as a placeholder — Phase 4 will add proper app icons; this makes the manifest valid without requiring new assets
- `"purpose": "any maskable"` tells Android Chrome the icon works for both standard and masked display modes
- Both `"application/pdf"` MIME type AND `".pdf"` extension are required — Chrome Android checks both; omitting either can cause the file to not be offered in the share sheet
- `"enctype": "multipart/form-data"` is required for file sharing (as opposed to title/url sharing which uses GET)

**Also add the manifest link to index.html** if not already present:
Check if `/workspace/index.html` has `<link rel="manifest" href="/manifest.json">`. If missing, add it inside `<head>`. This ensures Vite serves the manifest correctly in dev and production.
  </action>
  <verify>
    <automated>cd /workspace && cat public/manifest.json | python3 -m json.tool > /dev/null && echo "JSON valid" && grep -q "share_target" public/manifest.json && echo "share_target present"</automated>
    <manual>Confirm manifest.json is valid JSON with share_target, name, start_url, display, and icons fields.</manual>
  </verify>
  <done>public/manifest.json exists, is valid JSON, contains share_target with POST /share-target/ action accepting application/pdf files. index.html links to /manifest.json.</done>
</task>

<task type="auto">
  <name>Task 2: Create share-target-sw.js and wire SW registration + message listener in App.tsx</name>
  <files>public/share-target-sw.js, src/App.tsx</files>
  <action>
**Part A: Create public/share-target-sw.js**

This is a scoped service worker that handles only the `/share-target/` POST path. It is deliberately minimal — no app shell caching (that belongs to Phase 4's full service worker).

```javascript
// public/share-target-sw.js
// Scoped service worker for Web Share Target (IMPT-02).
// Handles POST requests to /share-target/ sent by Android Chrome when user
// shares a PDF into RSVP Reader from the system share sheet.
//
// Activation: This SW is registered by App.tsx with scope '/share-target/'.
// It only intercepts fetch events within that scope.
// Full share target functionality requires PWA installation (Phase 4).

const CACHE_NAME = 'share-target-v1'

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url)

  // Only handle POST requests to /share-target/ — let all other requests pass through
  if (event.request.method !== 'POST' || url.pathname !== '/share-target/') {
    return
  }

  event.respondWith(
    (async () => {
      try {
        const formData = await event.request.formData()
        const file = formData.get('pdf')

        if (file && file instanceof File) {
          // Store the shared file in Cache API temporarily
          // The main thread will retrieve it via the SHARED_PDF message
          const cache = await caches.open(CACHE_NAME)
          await cache.put('/shared-pdf', new Response(file, {
            headers: { 'Content-Type': file.type || 'application/pdf' }
          }))

          // Notify all open app windows about the shared file
          const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true })
          for (const client of clients) {
            client.postMessage({
              type: 'SHARED_PDF',
              filename: file.name,
              size: file.size,
            })
          }
        }
      } catch (err) {
        // Silently fail — the redirect below still returns the user to the app
        console.error('[share-target-sw] Error handling shared file:', err)
      }

      // Always redirect back to the app root after handling the share
      return Response.redirect('/?shared=1', 303)
    })()
  )
})
```

**Part B: Update src/App.tsx**

Add two behaviors to App.tsx:
1. Register the scoped service worker on mount (only in browsers that support it)
2. Listen for SHARED_PDF messages from the service worker and process the shared PDF

Import `useEffect` from React. Add `useNavigate` to the App component (or use a child component hook — but App.tsx does NOT use React Router hooks directly because BrowserRouter wraps App's children, not App itself).

**The correct pattern:** The SW registration and message listener should live in a `useEffect` inside App.tsx OR in a new component `ShareTargetHandler` rendered inside `<BrowserRouter>`. Use the latter pattern to access `useNavigate`:

Create a `ShareTargetHandler` component inside App.tsx (not a separate file — keep it in App.tsx as a local component):

```tsx
import { useEffect } from 'react'
import { BrowserRouter, Routes, Route, useNavigate } from 'react-router-dom'
import EntryScreen from './components/EntryScreen/EntryScreen'
import TextPreview from './components/TextPreview/TextPreview'
import RSVPReader from './components/RSVPReader/RSVPReader'
import { documentService } from './services/document-service'
import { useRsvpStore } from './store/rsvp-store'

/**
 * ShareTargetHandler — registered inside BrowserRouter so useNavigate is available.
 * Registers the scoped share-target service worker and listens for SHARED_PDF messages.
 * Renders nothing — side effects only.
 */
function ShareTargetHandler() {
  const navigate = useNavigate()
  const setDocument = useRsvpStore((s) => s.setDocument)

  useEffect(() => {
    // Register the scoped share-target service worker (IMPT-02)
    // Only available in browsers that support service workers
    if (!('serviceWorker' in navigator)) return

    navigator.serviceWorker
      .register('/share-target-sw.js', { scope: '/share-target/' })
      .catch((err) => {
        // Non-fatal: share target won't work but app functions normally
        console.warn('[share-target] SW registration failed:', err)
      })

    // Listen for SHARED_PDF messages from the service worker
    async function handleSwMessage(event: MessageEvent) {
      if (event.data?.type !== 'SHARED_PDF') return

      try {
        const cache = await caches.open('share-target-v1')
        const response = await cache.match('/shared-pdf')
        if (!response) return

        const blob = await response.blob()
        const file = new File([blob], event.data.filename ?? 'shared.pdf', {
          type: 'application/pdf',
        })

        // Process through the existing document pipeline
        const result = await documentService.parseFile(file)
        if (result.words.length >= 10) {
          setDocument(result.words, result.title)
          navigate('/preview')
        }

        // Clean up cached file after retrieval
        cache.delete('/shared-pdf')
      } catch (err) {
        console.error('[share-target] Failed to process shared file:', err)
      }
    }

    navigator.serviceWorker.addEventListener('message', handleSwMessage)
    return () => {
      navigator.serviceWorker.removeEventListener('message', handleSwMessage)
    }
  }, [navigate, setDocument]) // eslint-disable-line react-hooks/exhaustive-deps

  return null
}

export default function App() {
  return (
    <BrowserRouter>
      <ShareTargetHandler />
      <Routes>
        <Route path="/" element={<EntryScreen />} />
        <Route path="/preview" element={<TextPreview />} />
        <Route path="/read" element={<RSVPReader />} />
      </Routes>
    </BrowserRouter>
  )
}
```

**Critical notes:**
- `ShareTargetHandler` must be rendered INSIDE `<BrowserRouter>` so `useNavigate()` works
- `{ scope: '/share-target/' }` limits the SW to intercepting only that path — it will NOT intercept app shell requests
- `includeUncontrolled: true` in `matchAll` is needed because the app window may not be controlled by this scoped SW (it's only scoped to `/share-target/`)
- The SW registration failure is non-fatal — app works normally without it
- `cache.delete('/shared-pdf')` prevents stale files from being re-processed on next app open
  </action>
  <verify>
    <automated>cd /workspace && nvm use 22 2>/dev/null; npm run build 2>&1 | tail -5</automated>
    <manual>
1. Confirm public/share-target-sw.js exists and contains the fetch event listener
2. Confirm App.tsx imports useEffect and renders ShareTargetHandler inside BrowserRouter
3. Build exits 0 with no TypeScript errors
    </manual>
  </verify>
  <done>share-target-sw.js exists in public/. App.tsx renders ShareTargetHandler inside BrowserRouter. ShareTargetHandler registers the scoped SW and listens for SHARED_PDF messages. Build exits 0.</done>
</task>

</tasks>

<verification>
Run: `cd /workspace && nvm use 22 2>/dev/null; npm run build`
Expected: Exit 0, no TypeScript errors, public/share-target-sw.js and public/manifest.json included in dist/.

Run: `cd /workspace && ls dist/manifest.json dist/share-target-sw.js 2>/dev/null && echo "artifacts present"`
Expected: Both files present in production build output.
</verification>

<success_criteria>
1. public/manifest.json is valid JSON with share_target (POST, multipart/form-data, /share-target/, accepts application/pdf + .pdf)
2. public/share-target-sw.js handles POST /share-target/ — stores file in Cache API as 'share-target-v1', postMessages window clients with {type: 'SHARED_PDF', filename}
3. App.tsx registers share-target-sw.js with scope '/share-target/' and processes SHARED_PDF messages by retrieving the cached file, parsing it via documentService, and navigating to /preview
4. Build exits 0. All existing tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-import-ui-reading-view/03-02-SUMMARY.md`
</output>
