---
phase: 02-rsvp-playback-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/rsvp-store.ts
autonomous: true
requirements:
  - RSVP-04
  - CTRL-01
  - CTRL-02
  - CTRL-03
  - CTRL-04

must_haves:
  truths:
    - "useRsvpStore exposes wpm (number), isPlaying (boolean), currentWordIndex (number), jumpSize (number)"
    - "wpm defaults to 250, jumpSize defaults to 10, isPlaying defaults to false, currentWordIndex defaults to 0"
    - "wpm is persisted to localStorage key 'rsvp-settings' — survives page refresh"
    - "isPlaying, currentWordIndex, jumpSize are NOT persisted — reset to defaults on page refresh"
    - "setWpm, setIsPlaying, setCurrentWordIndex, setJumpSize, reset actions all exist in the store"
    - "Existing document state fields (wordList, documentTitle, isWorkerReady, setDocument, setWorkerReady, reset) still work identically"
  artifacts:
    - path: "src/store/rsvp-store.ts"
      provides: "Extended Zustand store with playback fields + persist middleware for wpm only"
      exports: ["useRsvpStore", "RsvpStore"]
      contains: "persist"
  key_links:
    - from: "src/store/rsvp-store.ts"
      to: "localStorage"
      via: "Zustand persist middleware with partialize — only wpm field persisted"
      pattern: "partialize.*wpm"
    - from: "src/store/rsvp-store.ts"
      to: "zustand/middleware"
      via: "import { persist, createJSONStorage } from 'zustand/middleware'"
      pattern: "createJSONStorage"
---

<objective>
Extend the existing Zustand store (`src/store/rsvp-store.ts`) with the Phase 2 playback fields. The Phase 1 store had only document state. Phase 2 adds `wpm`, `isPlaying`, `currentWordIndex`, and `jumpSize` — the four fields that power the RSVP scheduler, controls, and progress display.

WPM must be persisted to localStorage via Zustand's `persist` middleware with `partialize` (so only `wpm` is stored, not transient playback state). All other new fields are ephemeral and reset on page load.

Per STATE.md decision: "Phase 1 store shape — no Phase 2 fields yet; Phase 2 adds currentWordIndex, wpm, isPlaying."

Purpose: Foundational shared state that Plans 03, 04, and 05 all depend on. Must be Wave 1 so display and control components (Wave 2) can import the complete store interface.

Output: `src/store/rsvp-store.ts` rewritten with full Phase 1 + Phase 2 interface, persist middleware wrapping the store, and TypeScript-clean build.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-rsvp-playback-engine/02-RESEARCH.md
@src/store/rsvp-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend rsvp-store.ts with playback fields and persist middleware</name>
  <files>src/store/rsvp-store.ts</files>
  <action>
    Rewrite `src/store/rsvp-store.ts` to add Phase 2 fields while preserving all Phase 1 fields.

    New interface (merged Phase 1 + Phase 2):
    ```typescript
    import { create } from 'zustand'
    import { persist, createJSONStorage } from 'zustand/middleware'

    interface RsvpStore {
      // Document state (Phase 1 — unchanged)
      wordList: string[]
      documentTitle: string | null
      isWorkerReady: boolean

      // Playback state (Phase 2 — ephemeral, not persisted)
      currentWordIndex: number
      isPlaying: boolean
      jumpSize: number  // default: 10 words per jump press

      // Settings (Phase 2 — persisted to localStorage)
      wpm: number  // default: 250

      // Actions — Phase 1
      setDocument: (words: string[], title: string | null) => void
      setWorkerReady: (ready: boolean) => void

      // Actions — Phase 2 playback
      setCurrentWordIndex: (index: number) => void
      setIsPlaying: (playing: boolean) => void
      setJumpSize: (size: number) => void
      setWpm: (wpm: number) => void

      // Reset — resets document AND playback state (not wpm — that's persisted separately)
      reset: () => void
    }
    ```

    Initial state values:
    - wordList: [], documentTitle: null, isWorkerReady: false (Phase 1)
    - currentWordIndex: 0, isPlaying: false, jumpSize: 10 (Phase 2 ephemeral)
    - wpm: 250 (Phase 2 setting — default before hydration)

    The `reset` action resets ALL fields except wpm (wpm persists via middleware, reset should not touch it):
    ```typescript
    reset: () => set({
      wordList: [],
      documentTitle: null,
      isWorkerReady: false,
      currentWordIndex: 0,
      isPlaying: false,
      jumpSize: 10,
      // wpm intentionally NOT reset — persisted separately
    }),
    ```

    Wrap with persist middleware, partializing to wpm only:
    ```typescript
    export const useRsvpStore = create<RsvpStore>()(
      persist(
        (set) => ({
          // ...all fields and actions...
        }),
        {
          name: 'rsvp-settings',
          storage: createJSONStorage(() => localStorage),
          partialize: (state) => ({ wpm: state.wpm }),
        }
      )
    )
    ```

    CRITICAL: Do NOT use TypeScript `enum` keyword anywhere — use const objects with `as const` if needed (erasableSyntaxOnly tsconfig constraint from STATE.md).

    After writing the file, run TypeScript check and build to verify no existing code breaks.
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>No TypeScript errors. All Phase 1 components (EntryScreen, TextPreview, RSVPPlaceholder) still compile cleanly since they only use wordList, documentTitle, isWorkerReady, setDocument, setWorkerReady, reset — all still present.</manual>
  </verify>
  <done>
    src/store/rsvp-store.ts has all Phase 1 + Phase 2 fields. persist middleware wraps the store. partialize exports only wpm. TypeScript check passes (0 errors). npm run build compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify production build still passes after store change</name>
  <files>src/store/rsvp-store.ts</files>
  <action>
    Run the full production build to verify no regressions from the store change.

    Command: `nvm use 22 && npm run build`

    If the build fails with TypeScript errors in existing components (EntryScreen, TextPreview, RSVPPlaceholder), fix rsvp-store.ts to restore the missing types. Do NOT modify the Phase 1 components.

    If the build succeeds, commit: `feat(02-02): extend rsvp-store with playback fields and persist middleware`
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npm run build 2>&1 | tail -15</automated>
    <manual>Build exits 0. No "error TS" lines in output.</manual>
  </verify>
  <done>Production build exits 0. Store extension committed. Phase 2 store interface ready for Plans 03 and 04.</done>
</task>

</tasks>

<verification>
Run `nvm use 22 && npx tsc --noEmit` — 0 TypeScript errors.
Run `nvm use 22 && npm run build` — exits 0.
Inspect `src/store/rsvp-store.ts` — contains `persist`, `partialize`, `wpm: 250`, `currentWordIndex: 0`, `isPlaying: false`, `jumpSize: 10`.
</verification>

<success_criteria>
- rsvp-store exports the complete Phase 1 + Phase 2 interface with no breaking changes to Phase 1 consumers
- wpm field is persisted via Zustand persist middleware (localStorage key: 'rsvp-settings')
- isPlaying, currentWordIndex, jumpSize are ephemeral (not in partialize)
- wpm defaults to 250 per user decision (CONTEXT.md)
- jumpSize defaults to 10 per user decision (CONTEXT.md)
- TypeScript build passes, production build exits 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-rsvp-playback-engine/02-02-SUMMARY.md`
</output>
