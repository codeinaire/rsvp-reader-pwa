---
phase: 02-rsvp-playback-engine
plan: 05
type: execute
wave: 3
depends_on:
  - 02-03
  - 02-04
files_modified:
  - src/components/RSVPReader/RSVPReader.tsx
  - src/App.tsx
autonomous: true
requirements:
  - RSVP-01
  - RSVP-02
  - RSVP-03
  - RSVP-04
  - CTRL-01
  - CTRL-02
  - CTRL-03
  - CTRL-04

must_haves:
  truths:
    - "The /read route renders RSVPReader (not RSVPPlaceholder) — Phase 1 placeholder is replaced"
    - "Words advance automatically when isPlaying is true, using setTimeout + performance.now() deadline scheduler (no drift)"
    - "Pressing Play starts playback from currentWordIndex; pressing Pause freezes current index; resuming continues from where it stopped"
    - "Playback auto-pauses when the browser tab is hidden (visibilitychange) — prevents word burst on tab return"
    - "WPM changes take effect on the next word without restarting playback (wpmRef.current read at schedule time)"
    - "Space key toggles pause/resume; ArrowLeft jumps back; ArrowRight jumps forward — keyboard shortcuts active on /read route"
    - "Space key press does NOT double-fire button click — e.preventDefault() called in keydown handler"
    - "Playback stops naturally at the last word (isPlaying set to false, does not advance past wordList.length - 1)"
    - "Layout order (top to bottom): progress row → dark word panel (ORPDisplay) → controls row (PlaybackControls)"
    - "Guard redirect: if wordList is empty on mount, navigate back to / (no reading without document)"
  artifacts:
    - path: "src/components/RSVPReader/RSVPReader.tsx"
      provides: "RSVP reading screen — assembles ProgressBar + ORPDisplay + PlaybackControls with scheduler + keyboard + visibility hooks"
      exports: ["RSVPReader"]
      contains: "performance.now"
    - path: "src/App.tsx"
      provides: "Route /read wired to RSVPReader (was RSVPPlaceholder)"
      contains: "RSVPReader"
  key_links:
    - from: "src/components/RSVPReader/RSVPReader.tsx"
      to: "src/lib/scheduler.ts"
      via: "computeWordDelay called inside scheduler useEffect to determine setTimeout duration"
      pattern: "computeWordDelay"
    - from: "src/components/RSVPReader/RSVPReader.tsx"
      to: "src/components/RSVPReader/ORPDisplay.tsx"
      via: "import and render ORPDisplay with current word"
      pattern: "ORPDisplay"
    - from: "src/components/RSVPReader/RSVPReader.tsx"
      to: "src/components/RSVPReader/PlaybackControls.tsx"
      via: "import and render PlaybackControls below ORPDisplay"
      pattern: "PlaybackControls"
    - from: "src/components/RSVPReader/RSVPReader.tsx"
      to: "Page Visibility API"
      via: "document.addEventListener('visibilitychange', ...) — auto-pause on hide"
      pattern: "visibilitychange"
    - from: "src/App.tsx"
      to: "src/components/RSVPReader/RSVPReader.tsx"
      via: "Route element swap: RSVPPlaceholder removed, RSVPReader imported"
      pattern: "RSVPReader"
---

<objective>
Assemble the complete RSVP reading screen by:

1. Creating `RSVPReader.tsx` — the top-level `/read` screen component that:
   - Composes ProgressBar + ORPDisplay + PlaybackControls in the locked layout order
   - Owns the `performance.now()` deadline scheduler (setTimeout-based, drift-free)
   - Registers keyboard shortcuts (Space, ArrowLeft, ArrowRight) with stale-closure-safe refs
   - Registers visibilitychange listener to auto-pause on background tab
   - Guards: if wordList is empty on mount, navigates back to /
   - Stops playback cleanly at the last word

2. Updating `src/App.tsx` to replace the RSVPPlaceholder import/route with RSVPReader.

This is the final assembly plan. After this plan, the RSVP engine is complete and functional. Plan 06 (human checkpoint) verifies it.

Purpose: Wires all the pieces from Plans 01–04 into one working screen.

Output: `src/components/RSVPReader/RSVPReader.tsx`, updated `src/App.tsx`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/02-rsvp-playback-engine/02-CONTEXT.md
@.planning/phases/02-rsvp-playback-engine/02-RESEARCH.md
@.planning/phases/02-rsvp-playback-engine/02-03-SUMMARY.md
@.planning/phases/02-rsvp-playback-engine/02-04-SUMMARY.md
@src/App.tsx
@src/store/rsvp-store.ts
@src/lib/scheduler.ts
@src/components/RSVPReader/ORPDisplay.tsx
@src/components/RSVPReader/PlaybackControls.tsx
@src/components/RSVPReader/ProgressBar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RSVPReader.tsx — scheduler, keyboard, visibility, assembly</name>
  <files>src/components/RSVPReader/RSVPReader.tsx</files>
  <action>
    Create `src/components/RSVPReader/RSVPReader.tsx`.

    This component is the complete RSVP reading screen. It assembles display + controls and owns all side effects (scheduler, keyboard, visibility).

    SCHEDULER IMPLEMENTATION — read RESEARCH.md Pattern 3 carefully:
    - Use `useRef` for: `timeoutRef`, `wpmRef`, `isPlayingRef`, `wordListRef`
    - Keep refs in sync with store values via `useEffect` (one per ref)
    - The scheduler `useEffect` depends only on `[isPlaying]` — NOT on `currentWordIndex` or `wpm` (read those from refs at fire time)
    - When `isPlaying` becomes true: call `scheduleNext(currentWordIndex, performance.now())`
    - When `isPlaying` becomes false: `clearTimeout(timeoutRef.current)`
    - `scheduleNext(index, scheduledAt)`:
      1. Get `word = wordListRef.current[index]`
      2. If no word OR index >= wordList.length: set isPlaying = false, return (playback complete)
      3. `targetDelay = computeWordDelay(word, wpmRef.current)`
      4. `elapsed = performance.now() - scheduledAt`
      5. `remaining = Math.max(0, targetDelay - elapsed)`
      6. `timeoutRef.current = setTimeout(() => { if (!isPlayingRef.current) return; const next = index + 1; if (next >= wordListRef.current.length) { setIsPlaying(false); return; } setCurrentWordIndex(next); scheduleNext(next, performance.now()); }, remaining)`
    - useEffect cleanup: always `clearTimeout(timeoutRef.current ?? 0)`

    KEYBOARD SHORTCUTS — read RESEARCH.md Pattern 5:
    ```tsx
    useEffect(() => {
      function handleKey(e: KeyboardEvent) {
        if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return
        if (e.key === ' ') {
          e.preventDefault()
          setIsPlaying(!isPlayingRef.current)
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault()
          setCurrentWordIndex(Math.max(0, currentWordIndexRef.current - jumpSizeRef.current))
        } else if (e.key === 'ArrowRight') {
          e.preventDefault()
          setCurrentWordIndex(Math.min(wordListRef.current.length - 1, currentWordIndexRef.current + jumpSizeRef.current))
        }
      }
      window.addEventListener('keydown', handleKey)
      return () => window.removeEventListener('keydown', handleKey)
    }, [])  // Empty deps — reads from refs (stale-closure safe)
    ```
    Add `currentWordIndexRef` and `jumpSizeRef` alongside the other refs. Keep them in sync via useEffect.

    VISIBILITY AUTO-PAUSE — read RESEARCH.md Pattern 6:
    ```tsx
    useEffect(() => {
      function handleVisibility() {
        if (document.hidden && isPlayingRef.current) {
          setIsPlaying(false)
        }
      }
      document.addEventListener('visibilitychange', handleVisibility)
      return () => document.removeEventListener('visibilitychange', handleVisibility)
    }, [])
    ```

    GUARD REDIRECT — if wordList is empty on mount, navigate to /:
    ```tsx
    const navigate = useNavigate()
    useEffect(() => {
      if (wordList.length === 0) {
        navigate('/', { replace: true })
      }
    }, [])
    ```

    LAYOUT (locked per CONTEXT.md):
    ```tsx
    return (
      <div className="min-h-screen bg-gray-950 flex flex-col items-center justify-center px-4 gap-6">
        {/* Progress row — above word panel */}
        <ProgressBar />

        {/* Dark word panel — hero display */}
        <div className="bg-gray-900 rounded-2xl p-10 flex items-center justify-center">
          <ORPDisplay word={wordList[currentWordIndex] ?? ''} />
        </div>

        {/* Controls row — directly below dark panel */}
        <div className="w-full max-w-xl">
          <PlaybackControls />
        </div>
      </div>
    )
    ```

    TypeScript constraints (from STATE.md):
    - Do NOT use `enum` keyword — use `const` objects with `as const`
    - All timer IDs stored as `ReturnType<typeof setTimeout> | null`
    - `useCallback` is NOT needed for scheduleNext since it's called from within useEffect only (not passed as prop)

    After creation run: `nvm use 22 && npx tsc --noEmit`
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>
    RSVPReader.tsx exists. Contains: scheduleNext function using performance.now(), clearTimeout in useEffect cleanup, visibilitychange listener, keydown listener with e.preventDefault() on Space, guard redirect on empty wordList, layout with ProgressBar + ORPDisplay + PlaybackControls. No TS errors.
    </manual>
  </verify>
  <done>RSVPReader.tsx created, all scheduler/keyboard/visibility logic present, layout correct, TypeScript clean.</done>
</task>

<task type="auto">
  <name>Task 2: Wire RSVPReader into App.tsx and run production build</name>
  <files>src/App.tsx</files>
  <action>
    Read current `src/App.tsx`. Find the `/read` route which currently imports and renders `RSVPPlaceholder`. Replace it with `RSVPReader`.

    Changes to App.tsx:
    1. Remove: `import RSVPPlaceholder from './components/RSVPPlaceholder/RSVPPlaceholder'`
    2. Add: `import RSVPReader from './components/RSVPReader/RSVPReader'`
       (or named import if RSVPReader is exported as named — match the export style)
    3. Replace: `<Route path="/read" element={<RSVPPlaceholder />} />`
       With: `<Route path="/read" element={<RSVPReader />} />`

    The RSVPPlaceholder component file can remain on disk — just remove it from App.tsx import and routing. Do NOT delete the RSVPPlaceholder directory.

    After wiring, run the full production build:
    `nvm use 22 && npm run build`

    If build fails:
    - TS errors in RSVPReader: fix RSVPReader.tsx
    - TS errors in App.tsx: fix the import/route change
    - Do NOT touch Phase 1 components (EntryScreen, TextPreview)

    On build success, commit both files:
    `feat(02-05): assemble RSVPReader screen — replace placeholder, wire scheduler and controls`
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npm run build 2>&1 | tail -20</automated>
    <manual>Build exits 0. No "error TS" lines. The dist/ directory has updated JS bundle. RSVPReader is in the bundle.</manual>
  </verify>
  <done>App.tsx imports RSVPReader at /read. Production build exits 0. RSVPReader.tsx and App.tsx committed.</done>
</task>

</tasks>

<verification>
TypeScript check: `nvm use 22 && npx tsc --noEmit` — 0 errors.
Production build: `nvm use 22 && npm run build` — exits 0.
RSVPReader.tsx contains: `performance.now`, `visibilitychange`, `keydown`, `e.preventDefault()`, `clearTimeout`, `scheduleNext`.
App.tsx imports RSVPReader (not RSVPPlaceholder) at `/read` route.
Run all lib tests still pass: `nvm use 22 && npx vitest run src/lib/`
</verification>

<success_criteria>
- RSVP engine is fully assembled and functional at the /read route
- Scheduler uses performance.now() for drift-free timing (no setInterval)
- WPM changes from slider take effect on next word (wpmRef pattern)
- Background tab auto-pauses playback (visibilitychange)
- Keyboard: Space=toggle, ArrowLeft=jump back, ArrowRight=jump forward
- Space key does not double-fire button click (e.preventDefault())
- Playback stops at last word without crashing
- Production build exits 0 with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-rsvp-playback-engine/02-05-SUMMARY.md`
</output>
