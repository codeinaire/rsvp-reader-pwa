---
phase: 02-rsvp-playback-engine
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/orp.ts
  - src/lib/scheduler.ts
  - src/lib/orp.test.ts
  - src/lib/scheduler.test.ts
autonomous: true
requirements:
  - RSVP-01
  - RSVP-02
  - RSVP-03

must_haves:
  truths:
    - "computeOrp('Hello') returns { left: 'H', focal: 'e', right: 'llo' } — ORP focal at index 1 (ceil(5*0.3)-1=0, hmm: 5*0.3=1.5, ceil=2, -1=1 -> index 1)"
    - "computeOrp('I') returns { left: '', focal: 'I', right: '' } — single character word is all focal"
    - "computeOrp('transformation') returns focal at index 3 — long words use index 3 per locked formula"
    - "computeWordDelay('Hello', 300) returns approximately 200ms base — 60000/300=200 * length multiplier for 5-letter word"
    - "computeWordDelay('end.', 300) returns 1.5x the base delay — sentence-ending punctuation multiplier applied"
    - "computeWordDelay('a', 300) returns 0.8x the base delay — short word (<=2 letters) gets faster multiplier"
    - "computeWordDelay('transformation', 300) returns 1.5x the base delay — long word (10+ letters) gets slow multiplier"
  artifacts:
    - path: "src/lib/orp.ts"
      provides: "computeOrp(word) -> OrpFragments — grapheme-aware ORP split using Intl.Segmenter"
      exports: ["computeOrp", "OrpFragments"]
    - path: "src/lib/scheduler.ts"
      provides: "computeWordDelay(word, wpm) -> ms — word display duration with length and sentence multipliers"
      exports: ["computeWordDelay"]
    - path: "src/lib/orp.test.ts"
      provides: "Test suite covering single-char, 2-char, 3-6 char, 7-9 char, 10+ char words plus Unicode"
    - path: "src/lib/scheduler.test.ts"
      provides: "Test suite covering each length category, sentence-ending punctuation, base WPM math"
  key_links:
    - from: "src/lib/orp.ts"
      to: "Intl.Segmenter"
      via: "grapheme cluster iteration — never raw .length"
      pattern: "Intl\\.Segmenter"
    - from: "src/lib/scheduler.ts"
      to: "computeOrp"
      via: "scheduler imports none of orp — they are independent pure functions"
      pattern: "60_000 / wpm"
---

<objective>
TDD implementation of the two pure-function business logic modules that power the RSVP engine:

1. `computeOrp(word)` — splits any word into (left, focal, right) fragments using grapheme clusters (Intl.Segmenter). The focal character index is `Math.max(0, Math.ceil(graphemes.length * 0.3) - 1)`. This is the locked formula from STATE.md.

2. `computeWordDelay(word, wpm)` — returns the millisecond display duration for a word at a given WPM, applying word-length normalization (short words faster, long words slower) and a 1.5x sentence-pause multiplier for words ending in `.`, `!`, or `?`.

Purpose: These are the core algorithms. TDD ensures correctness before they are wired into the React component tree. The ORP formula and timing multipliers are locked in RESEARCH.md and STATE.md — no implementation choices required.

Output: `src/lib/orp.ts`, `src/lib/scheduler.ts`, `src/lib/orp.test.ts`, `src/lib/scheduler.test.ts` — tested, passing, committed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-rsvp-playback-engine/02-RESEARCH.md
@src/lib/tokenize.ts
</context>

<feature>
  <name>ORP Fragment Computation (orp.ts)</name>
  <files>src/lib/orp.ts, src/lib/orp.test.ts</files>
  <behavior>
    computeOrp(word: string): OrpFragments

    Uses a module-level `const segmenter = new Intl.Segmenter(undefined, { granularity: 'grapheme' })`.
    Splits word into grapheme array. Computes ORP index: `Math.max(0, Math.ceil(graphemes.length * 0.3) - 1)`.

    Test cases (inputs -> {left, focal, right}):
    - "I"            -> { left: "", focal: "I", right: "" }              (1 grapheme, orp=0)
    - "is"           -> { left: "", focal: "i", right: "s" }             (2 graphemes, orp=0)
    - "the"          -> { left: "t", focal: "h", right: "e" }            (3 graphemes, ceil(0.9)-1=0... wait: ceil(3*0.3)=ceil(0.9)=1, 1-1=0, max(0,0)=0 -> focal at index 0)
    - "word"         -> { left: "w", focal: "o", right: "rd" }           (4 graphemes, ceil(4*0.3)=ceil(1.2)=2, 2-1=1, orp=1)
    - "Hello"        -> { left: "He", focal: "l", right: "lo" }          (5 graphemes, ceil(1.5)=2, 2-1=1, orp=1)
    - "reading"      -> { left: "re", focal: "a", right: "ding" }        (7 graphemes, ceil(2.1)=3, 3-1=2, orp=2)
    - "excellent"    -> { left: "exc", focal: "e", right: "llent" }      (9 graphemes, ceil(2.7)=3, 3-1=2, orp=2)
    - "transformer"  -> { left: "tra", focal: "n", right: "sformer" }    (11 graphemes, ceil(3.3)=4, 4-1=3, orp=3)
    - "café"         -> Unicode test: grapheme splitting separates "é" correctly (Intl.Segmenter handles combining marks)
    - ""             -> { left: "", focal: "", right: "" }               (empty string: graphemes=[], focal=graphemes[0]??"", orp=max(0,ceil(0*0.3)-1)=max(0,-1)=0)

    The test file uses Vitest (already installed in the project).
  </behavior>
  <implementation>
    Create `src/lib/orp.ts`:
    - Export interface `OrpFragments { left: string; focal: string; right: string }`
    - Module-level `const segmenter = new Intl.Segmenter(undefined, { granularity: 'grapheme' })`
    - Export `computeOrp(word: string): OrpFragments`
    - Never use raw `word.length` — always spread segmenter output
    - Handle empty string: if graphemes.length === 0, return { left: "", focal: "", right: "" }

    Create `src/lib/orp.test.ts`:
    - Import computeOrp from './orp'
    - One describe block "computeOrp"
    - Test each case listed in behavior above with it() / expect().toEqual()
  </implementation>
</feature>

<feature>
  <name>Word Delay Computation (scheduler.ts)</name>
  <files>src/lib/scheduler.ts, src/lib/scheduler.test.ts</files>
  <behavior>
    computeWordDelay(word: string, wpm: number): number

    1. Base delay: `60_000 / wpm` (ms per word at target WPM)
    2. Strip non-letter chars to count letters: `word.replace(/\W/g, '')`. If zero letters, treat length as 1.
    3. Length multiplier based on letter count:
       - <= 2 letters: 0.8
       - 3-6 letters: 1.0
       - 7-9 letters: 1.2
       - 10+ letters: 1.5
    4. Sentence multiplier: 1.5 if word matches `/[.!?]['"]?\s*$/`, else 1.0
    5. Return: baseMs * lengthMultiplier * sentenceMult

    Test cases (all at wpm=300, base=200ms):
    - "I"            -> 200 * 0.8 * 1.0 = 160     (1 letter, no sentence end)
    - "is"           -> 200 * 0.8 * 1.0 = 160     (2 letters, no sentence end)
    - "the"          -> 200 * 1.0 * 1.0 = 200     (3 letters, no sentence end)
    - "Hello"        -> 200 * 1.0 * 1.0 = 200     (5 letters, no sentence end)
    - "reading"      -> 200 * 1.2 * 1.0 = 240     (7 letters, no sentence end)
    - "excellent"    -> 200 * 1.2 * 1.0 = 240     (9 letters, no sentence end)
    - "transformer"  -> 200 * 1.5 * 1.0 = 300     (11 letters, no sentence end)
    - "end."         -> 200 * 1.0 * 1.5 = 300     (3 letters, sentence-ending period)
    - "done!"        -> 200 * 1.0 * 1.5 = 300     (4 letters, sentence-ending exclamation)
    - "really?"      -> 200 * 1.0 * 1.5 = 300     (6 letters, sentence-ending question mark)
    - "word..."      -> test: "..." after stripping: letters="word" (4 chars), sentence match on "..." (ends with .)
    - WPM accuracy: computeWordDelay("the", 600) === 100 (60000/600 * 1.0 * 1.0)
  </behavior>
  <implementation>
    Create `src/lib/scheduler.ts`:
    - Export `computeWordDelay(word: string, wpm: number): number`
    - No imports needed — pure arithmetic
    - Use the exact multiplier table and regex from RESEARCH.md code examples

    Create `src/lib/scheduler.test.ts`:
    - Import computeWordDelay from './scheduler'
    - One describe block "computeWordDelay"
    - Test every case listed in behavior section
    - Verify WPM math correctness (double-check base formula)
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>Task 1: RED — write failing tests for orp.ts and scheduler.ts</name>
  <files>src/lib/orp.test.ts, src/lib/scheduler.test.ts</files>
  <action>
    Create `src/lib/orp.test.ts` with the full test suite for computeOrp. Test cases must cover: empty string, 1-char, 2-char, 3-char, 4-char, 5-char (each with exact ORP index computed from formula), 7-char, 9-char, 11-char, and the café Unicode case. Import `computeOrp` from './orp' — the module does not exist yet, so the test file will fail to compile.

    Create `src/lib/scheduler.test.ts` with the full test suite for computeWordDelay. Test all length categories (1-2, 3-6, 7-9, 10+), sentence-ending punctuation (period, !, ?), and WPM math accuracy. Import `computeWordDelay` from './scheduler'.

    Run: `nvm use 22 && npx vitest run src/lib/orp.test.ts src/lib/scheduler.test.ts`

    Expected: Tests FAIL (modules don't exist yet). If tests pass at this stage, something is wrong — stop and investigate before proceeding.

    Commit: `test(02-01): add failing tests for computeOrp and computeWordDelay`
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npx vitest run src/lib/orp.test.ts src/lib/scheduler.test.ts 2>&1 | grep -E "FAIL|Cannot find|error" | head -20</automated>
    <manual>Confirm the output shows import/module-not-found errors — RED state confirmed</manual>
  </verify>
  <done>Both test files exist. Running vitest produces errors (cannot find module './orp', './scheduler'). RED state confirmed.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — implement orp.ts and scheduler.ts until all tests pass</name>
  <files>src/lib/orp.ts, src/lib/scheduler.ts</files>
  <action>
    Create `src/lib/orp.ts`:
    - Export interface `OrpFragments { left: string; focal: string; right: string }`
    - Module-level singleton: `const segmenter = new Intl.Segmenter(undefined, { granularity: 'grapheme' })`
    - Export `computeOrp(word: string): OrpFragments`:
      - `const graphemes = [...segmenter.segment(word)].map((s) => s.segment)`
      - `if (graphemes.length === 0) return { left: '', focal: '', right: '' }`
      - `const orpIndex = Math.max(0, Math.ceil(graphemes.length * 0.3) - 1)`
      - Return `{ left: graphemes.slice(0, orpIndex).join(''), focal: graphemes[orpIndex] ?? '', right: graphemes.slice(orpIndex + 1).join('') }`

    Create `src/lib/scheduler.ts`:
    - Export `computeWordDelay(word: string, wpm: number): number`:
      - `const baseMs = 60_000 / wpm`
      - `const letters = word.replace(/\W/g, '')`
      - `const len = letters.length || 1`
      - Length multiplier: `let lengthMult = 1.0; if (len <= 2) lengthMult = 0.8; else if (len <= 6) lengthMult = 1.0; else if (len <= 9) lengthMult = 1.2; else lengthMult = 1.5`
      - Sentence: `const sentenceMult = /[.!?]['"]?\s*$/.test(word) ? 1.5 : 1.0`
      - Return `baseMs * lengthMult * sentenceMult`

    Run tests: `nvm use 22 && npx vitest run src/lib/orp.test.ts src/lib/scheduler.test.ts`

    Fix any failures — adjust implementation (NOT tests) until all pass.

    Commit: `feat(02-01): implement computeOrp and computeWordDelay`
  </action>
  <verify>
    <automated>cd /Users/nousunio/Repos/Learnings/claude-code/rsvp-reader-pwa && nvm use 22 && npx vitest run src/lib/orp.test.ts src/lib/scheduler.test.ts 2>&1 | tail -10</automated>
    <manual>Output shows "Tests X passed" with 0 failures</manual>
  </verify>
  <done>All orp.test.ts and scheduler.test.ts tests pass. GREEN state. Both files committed.</done>
</task>

</tasks>

<verification>
Run the full test suite: `nvm use 22 && npx vitest run src/lib/`
All tests pass (0 failures).
TypeScript check: `nvm use 22 && npx tsc --noEmit` — 0 errors.
Both src/lib/orp.ts and src/lib/scheduler.ts exist and export the expected functions.
</verification>

<success_criteria>
- `computeOrp` correctly places the ORP focal character for words of 1, 2, 3-6, 7-9, and 10+ graphemes
- `computeOrp` handles Unicode correctly (café test passes — Intl.Segmenter used, not raw .length)
- `computeWordDelay` returns correct ms for each word-length category at 300 WPM
- Sentence-ending punctuation produces exactly 1.5× multiplier on the delay
- All tests GREEN, 0 TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-rsvp-playback-engine/02-01-SUMMARY.md`
</output>
