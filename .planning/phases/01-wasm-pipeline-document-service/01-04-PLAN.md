---
phase: 01-wasm-pipeline-document-service
plan: "04"
type: execute
wave: 3
depends_on:
  - "01-02"
  - "01-03"
files_modified:
  - src/workers/worker-types.ts
  - src/workers/parser-worker.ts
  - src/services/document-service.ts
  - src/lib/tokenize.ts
  - src/lib/format-detect.ts
autonomous: true
requirements:
  - DOCF-01
  - IMPT-04

must_haves:
  truths:
    - "DocumentService.parseText(text) returns a word array synchronously (no WASM involved)"
    - "DocumentService.parseFile(pdf) sends bytes to the Worker and resolves with a word array"
    - "The Worker initializes WASM lazily and reports ready state back to DocumentService"
    - "Concurrent parse requests are handled via request ID map — requests do not cross-contaminate"
    - "Binary files are transferred (not copied) — bytes.buffer is in Transferable list"
    - "TypeScript compiles with no errors across all five files"
  artifacts:
    - path: "src/workers/worker-types.ts"
      provides: "Shared TypeScript message type definitions for Worker↔main thread protocol"
      contains: "ParseMessageType"
    - path: "src/workers/parser-worker.ts"
      provides: "Web Worker that loads WASM once, handles parse_pdf messages"
      contains: "initialize()"
    - path: "src/services/document-service.ts"
      provides: "Main-thread facade: Promise API over Worker, lazy WASM init"
      contains: "class DocumentService"
    - path: "src/lib/tokenize.ts"
      provides: "tokenize(text: string): string[] — whitespace split, empty filter"
      contains: "export function tokenize"
    - path: "src/lib/format-detect.ts"
      provides: "detectFormat(filename, mimeType): DocFormat — extension + MIME detection"
      contains: "export function detectFormat"
  key_links:
    - from: "src/services/document-service.ts"
      to: "src/workers/parser-worker.ts"
      via: "new Worker(new URL('../workers/parser-worker.ts', import.meta.url), {type:'module'})"
      pattern: "import.meta.url"
    - from: "src/workers/parser-worker.ts"
      to: "rsvp-parser/crates/rsvp-parser/pkg/rsvp_parser.js"
      via: "import init, { parse_pdf } from WASM pkg"
      pattern: "from.*rsvp_parser"
    - from: "src/services/document-service.ts"
      to: "src/lib/tokenize.ts"
      via: "parseText() and txt format path use tokenize()"
      pattern: "tokenize"
---

<objective>
Implement the complete WASM Worker pipeline: message types, parser-worker.ts (WASM host), DocumentService (main-thread facade), tokenizer, and format detector. After this plan, the data path from file bytes or pasted text to word array is fully operational.

Purpose: This is the core infrastructure all import flows depend on. EntryScreen (Plan 05) cannot be built until DocumentService exists. The patterns come directly from the working rust-image-tools workspace reference (HIGH confidence).

Output: Five TypeScript files implementing the Worker↔main-thread protocol. documentService singleton exported for use by EntryScreen.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-wasm-pipeline-document-service/01-RESEARCH.md
@.planning/phases/01-wasm-pipeline-document-service/01-01-SUMMARY.md
@.planning/phases/01-wasm-pipeline-document-service/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker-types.ts, tokenize.ts, and format-detect.ts</name>
  <files>
    src/workers/worker-types.ts
    src/lib/tokenize.ts
    src/lib/format-detect.ts
  </files>
  <action>
Create `src/workers/worker-types.ts` — all shared types for the Worker↔main thread protocol:

```typescript
/**
 * Shared TypeScript types for the parser Worker message protocol.
 * Both parser-worker.ts and document-service.ts import from here.
 * Never import these in React components — use ParseResult from document-service.ts instead.
 */

export enum ParseMessageType {
  Init = 'init',
  ParseDocument = 'parse_document',
  Error = 'error',
}

/** Document formats the Worker can parse. txt is handled on the main thread. */
export type DocFormat = 'pdf' | 'txt'

// ── Main thread → Worker ───────────────────────────────────────────────────────

export interface ParseRequest {
  type: ParseMessageType.ParseDocument
  id: number
  format: DocFormat
  data: Uint8Array  // Transferred (not copied) — Worker owns buffer after postMessage
}

// ── Worker → Main thread ───────────────────────────────────────────────────────

export interface InitSuccessResponse {
  type: ParseMessageType.Init
  success: true
  initMs: number
}

export interface InitErrorResponse {
  type: ParseMessageType.Init
  success: false
  error: string
}

export interface ParseSuccessResponse {
  type: ParseMessageType.ParseDocument
  id: number
  success: true
  words: string[]
  title: string | null
  parseMs: number
}

export interface ParseErrorResponse {
  type: ParseMessageType.Error
  id: number
  error: string
}

export type WorkerResponse =
  | InitSuccessResponse
  | InitErrorResponse
  | ParseSuccessResponse
  | ParseErrorResponse
```

---

Create `src/lib/tokenize.ts`:

```typescript
/**
 * Split text into a word array for RSVP display.
 *
 * Design:
 * - Splits on any whitespace sequence (\s+ handles tabs, newlines, \r\n, multiple spaces)
 * - Preserves punctuation within words (period, comma, etc.) for reading rhythm
 * - Filters empty strings that result from leading/trailing whitespace
 *
 * Used by DocumentService for:
 * - The paste-text path (IMPT-04) — runs on main thread, no WASM needed
 * - The txt file format path
 */
export function tokenize(text: string): string[] {
  return text
    .split(/\s+/)
    .map((w) => w.trim())
    .filter((w) => w.length > 0)
}
```

---

Create `src/lib/format-detect.ts`:

```typescript
/**
 * Detect document format from filename and MIME type.
 *
 * Design:
 * - Extension check takes priority over MIME (some browsers report wrong MIME for PDFs)
 * - Falls back to 'txt' for anything unrecognized — safe default
 * - 'txt' signals to DocumentService to handle on the main thread (no Worker needed)
 */
export type DocFormat = 'pdf' | 'txt'

export function detectFormat(filename: string, mimeType: string): DocFormat {
  const lower = filename.toLowerCase()

  // PDF: check extension first, then MIME
  if (lower.endsWith('.pdf') || mimeType === 'application/pdf') {
    return 'pdf'
  }

  // All other formats (including .txt) — tokenized on main thread
  return 'txt'
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` from project root. No TypeScript errors in the three files. Also verify `src/workers/worker-types.ts` exports ParseMessageType, DocFormat, ParseRequest, and WorkerResponse.
  </verify>
  <done>
Three files exist with correct exports. TypeScript compiles without errors. DocFormat is 'pdf' | 'txt'. ParseMessageType enum has Init, ParseDocument, Error values.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create parser-worker.ts and document-service.ts</name>
  <files>
    src/workers/parser-worker.ts
    src/services/document-service.ts
  </files>
  <action>
Create `src/workers/parser-worker.ts`.

CRITICAL NOTES from research:
- `--target bundler` output (from Plan 02 spike) expects ESM imports — `import init, { parse_pdf }` is correct
- Import path is relative to the worker file: `../../rsvp-parser/crates/rsvp-parser/pkg/rsvp_parser.js`
- `declare function postMessage(...)` avoids TypeScript confusing Worker's postMessage with Window's
- Call `initialize()` at module evaluation time — WASM loads as soon as the Worker starts

```typescript
// TypeScript declaration to avoid Window.postMessage type conflict in Worker context
declare function postMessage(message: unknown, transfer?: Transferable[]): void

import init, { parse_pdf } from '../../rsvp-parser/crates/rsvp-parser/pkg/rsvp_parser.js'
import { ParseMessageType } from './worker-types'
import type { WorkerResponse, ParseRequest } from './worker-types'

async function initialize(): Promise<void> {
  const start = performance.now()
  try {
    await init()
    const initMs = Math.round(performance.now() - start)
    const response: WorkerResponse = {
      type: ParseMessageType.Init,
      success: true,
      initMs,
    }
    postMessage(response)
  } catch (e) {
    const error = e instanceof Error ? e.message : String(e)
    const response: WorkerResponse = {
      type: ParseMessageType.Init,
      success: false,
      error,
    }
    postMessage(response)
  }
}

onmessage = (event: MessageEvent<ParseRequest>) => {
  const req = event.data
  const start = performance.now()
  try {
    let result: { words: string[]; title: string | null }

    if (req.format === 'pdf') {
      // parse_pdf is the #[wasm_bindgen] export from rsvp-parser lib.rs
      // It returns a JsValue (deserialized to ParseResult shape) or throws JsError
      result = parse_pdf(req.data) as { words: string[]; title: string | null }
    } else {
      // txt format should not reach the Worker (DocumentService handles it on main thread)
      throw new Error(`Unexpected format in Worker: ${req.format}`)
    }

    const parseMs = Math.round(performance.now() - start)
    const response: WorkerResponse = {
      type: ParseMessageType.ParseDocument,
      id: req.id,
      success: true,
      words: result.words,
      title: result.title,
      parseMs,
    }
    postMessage(response)
  } catch (e) {
    const error = e instanceof Error ? e.message : String(e)
    const response: WorkerResponse = {
      type: ParseMessageType.Error,
      id: req.id,
      error,
    }
    postMessage(response)
  }
}

// Initialize WASM immediately when Worker is created.
// The Worker posts Init success/failure back to DocumentService.
// DocumentService resolves/rejects its `ready` promise on receipt.
initialize()
```

---

Create `src/services/document-service.ts`:

```typescript
import { ParseMessageType } from '../workers/worker-types'
import type { WorkerResponse, ParseRequest } from '../workers/worker-types'
import { tokenize } from '../lib/tokenize'
import { detectFormat } from '../lib/format-detect'

export interface ParseResult {
  words: string[]
  title: string | null
  parseMs: number
}

type PendingRequest = {
  resolve: (value: ParseResult) => void
  reject: (reason: Error) => void
}

class DocumentService {
  private readonly worker: Worker
  private readonly ready: Promise<void>
  private resolveReady!: () => void
  private rejectReady!: (e: Error) => void
  private readonly pending = new Map<number, PendingRequest>()
  private nextId = 1

  constructor() {
    this.ready = new Promise<void>((resolve, reject) => {
      this.resolveReady = resolve
      this.rejectReady = reject
    })

    // Vite resolves the Worker URL at build time from import.meta.url.
    // type: 'module' is required for ES module workers (imports inside worker file).
    this.worker = new Worker(
      new URL('../workers/parser-worker.ts', import.meta.url),
      { type: 'module' },
    )

    this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {
      const msg = event.data

      if (msg.type === ParseMessageType.Init) {
        if (msg.success) {
          this.resolveReady()
        } else {
          this.rejectReady(new Error(`WASM init failed: ${msg.error}`))
        }
        return
      }

      // Parse response — look up pending request by ID
      const req = this.pending.get(msg.id)
      if (!req) return
      this.pending.delete(msg.id)

      if (msg.type === ParseMessageType.Error) {
        req.reject(new Error(msg.error))
      } else if (msg.type === ParseMessageType.ParseDocument && msg.success) {
        req.resolve({ words: msg.words, title: msg.title, parseMs: msg.parseMs })
      }
    }

    this.worker.onerror = (e) => {
      const err = new Error(e.message ?? 'Worker crashed')
      this.rejectReady(err)
      for (const [, req] of this.pending) {
        req.reject(new Error('Worker crashed unexpectedly'))
      }
      this.pending.clear()
    }
  }

  /**
   * Returns a promise that resolves when WASM initialization is complete.
   * Used by EntryScreen to enable/disable the import button.
   * Safe to call multiple times — resolves immediately after first init.
   */
  ensureReady(): Promise<void> {
    return this.ready
  }

  /**
   * Parse a File object. Detects format from name + MIME type.
   *
   * PDF files: sent as Uint8Array to the Worker (zero-copy transfer).
   * Plain text files: read as text, tokenized on main thread (no WASM).
   *
   * @throws Error with a user-facing message if extraction fails or PDF is scanned.
   */
  async parseFile(file: File): Promise<ParseResult> {
    await this.ready
    const format = detectFormat(file.name, file.type)

    // Plain text: no WASM needed — tokenize on main thread
    if (format === 'txt') {
      const text = await file.text()
      const words = tokenize(text)
      return {
        words,
        title: file.name.replace(/\.[^.]+$/, ''), // strip extension for title
        parseMs: 0,
      }
    }

    // Binary formats: transfer bytes to Worker (zero-copy)
    // IMPORTANT: Use arrayBuffer() NOT text() — text() corrupts binary files
    const bytes = new Uint8Array(await file.arrayBuffer())
    const id = this.nextId++
    const request: ParseRequest = {
      type: ParseMessageType.ParseDocument,
      id,
      format,
      data: bytes,
    }
    // Transfer bytes.buffer — after this call, bytes is detached (Worker owns it)
    this.worker.postMessage(request, [bytes.buffer])

    return new Promise<ParseResult>((resolve, reject) => {
      this.pending.set(id, { resolve, reject })
    })
  }

  /**
   * Parse raw text string (paste path — IMPT-04).
   * Synchronous. No WASM involved.
   */
  parseText(text: string): ParseResult {
    return {
      words: tokenize(text),
      title: null,
      parseMs: 0,
    }
  }
}

// Singleton — starts WASM initialization as a side effect of import.
// Import this in main.tsx BEFORE createRoot() so init starts early,
// but NEVER await ensureReady() before createRoot().render().
export const documentService = new DocumentService()
```
  </action>
  <verify>
Run `npx tsc --noEmit` — no TypeScript errors. Confirm:
- `src/workers/parser-worker.ts` exists and imports from `./worker-types`
- `src/services/document-service.ts` exports `documentService` and `ParseResult`
- The import URL in DocumentService uses `import.meta.url` pattern
  </verify>
  <done>
Five TypeScript files exist (worker-types.ts, parser-worker.ts, document-service.ts, tokenize.ts, format-detect.ts). `npx tsc --noEmit` exits 0 with no errors. documentService singleton is exported. parseText() is synchronous. parseFile() returns a Promise and transfers bytes to the Worker.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no errors across all five new files
2. `src/workers/worker-types.ts` exports ParseMessageType enum, DocFormat, WorkerResponse union
3. `src/services/document-service.ts` exports documentService (singleton) and ParseResult interface
4. `src/workers/parser-worker.ts` calls `initialize()` at module evaluation time
5. WASM import path in parser-worker.ts uses `../../rsvp-parser/crates/rsvp-parser/pkg/rsvp_parser.js`
6. postMessage call in DocumentService includes `[bytes.buffer]` in Transferable list
</verification>

<success_criteria>
- All five files exist with correct TypeScript exports
- No TypeScript compilation errors
- Worker init pattern matches rust-image-tools reference (initialize() at module eval time)
- Binary transfer (not copy) used for PDF bytes
- Paste path (parseText) is synchronous and needs no WASM
- Format detection handles PDF by extension AND MIME type
</success_criteria>

<output>
After completion, create `/Users/nousunio/Repos/Learnings/claude-code/text-to-voice/.planning/phases/01-wasm-pipeline-document-service/01-04-SUMMARY.md`
</output>
